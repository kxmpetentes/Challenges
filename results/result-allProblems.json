{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Enum 'switch' statement that misses case",
  "severity": "High",
  "comment": "`switch (environment) { case NORMAL: return worlds.get(0); case NETHER: return worlds.get(1); ...` statement on enum type 'org.bukkit.World.Environment' misses case 'CUSTOM'",
  "detailsInfo": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/PositionSetting.java",
      "language": "JAVA",
      "line": 321,
      "offset": 3,
      "length": 141,
      "code": {
        "startLine": 319,
        "length": 141,
        "offset": 124,
        "surroundingCode": "\tpublic static World getWorldByEnvironment(@Nonnull Environment environment) {\n\t\tList<World> worlds = Bukkit.getWorlds();\n\t\tswitch (environment) {\n\t\t\tcase NORMAL: return worlds.get(0);\n\t\t\tcase NETHER: return worlds.get(1);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EnumSwitchStatementWhichMissesCases"
  },
  "hash": "dbca2441e82295010d02b5ee81bda966403def4097096ca2a664fca69f5927f0"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Enum 'switch' statement that misses case",
  "severity": "High",
  "comment": "`switch (this) { case AMBIENT: return world.getAmbientSpawnLimit(); case HOSTILE: ...` statement on enum type 'net.codingarea.challenges.plugin.challenges.implementation.challenge.MobRandomizerChallenge.EntityCategory' misses case 'OTHER'",
  "detailsInfo": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MobRandomizerChallenge.java",
      "language": "JAVA",
      "line": 195,
      "offset": 4,
      "length": 493,
      "code": {
        "startLine": 193,
        "length": 493,
        "offset": 56,
        "surroundingCode": "\n\t\tprivate int getSpawnLimit(@Nonnull World world) {\n\t\t\tswitch (this) {\n\t\t\t\tcase AMBIENT:       return world.getAmbientSpawnLimit();\n\t\t\t\tcase HOSTILE:       return world.getMonsterSpawnLimit();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EnumSwitchStatementWhichMissesCases"
  },
  "hash": "230d3b3c7d11e9e1807d43c649cfa5b9116795f7c86e7227af7e95349f7a2b1d"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Enum 'switch' statement that misses case",
  "severity": "High",
  "comment": "`switch (event.getAction()) { case LEFT_CLICK_AIR: case LEFT_CLICK_BLOCK: case PHYSICAL: ...` statement on enum type 'org.bukkit.event.block.Action' misses cases: 'RIGHT_CLICK_BLOCK', and 'RIGHT_CLICK_AIR'",
  "detailsInfo": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/inventory/PlayerInventoryManager.java",
      "language": "JAVA",
      "line": 86,
      "offset": 3,
      "length": 112,
      "code": {
        "startLine": 84,
        "length": 112,
        "offset": 79,
        "surroundingCode": "\t@EventHandler\n\tpublic void onInteract(@Nonnull PlayerInteractEvent event) {\n\t\tswitch (event.getAction()) {\n\t\t\tcase LEFT_CLICK_AIR:\n\t\t\tcase LEFT_CLICK_BLOCK:"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EnumSwitchStatementWhichMissesCases"
  },
  "hash": "f641167f5278e430963102c8567cae6786ecc02d0f8502dea89a30e6985f6a86"
},{
  "tool": "Code Inspection",
  "category": "Class",
  "type": "Class name same as ancestor name",
  "severity": "High",
  "comment": "Class name `ItemBuilder` is the same as one of its superclass' names",
  "detailsInfo": "Reports classes that have the same name as one of their superclasses, while their fully qualified names remain different. Such class names may be very confusing.\n\n**Example:**\n\n\n      package util;\n      abstract class Iterable<T> implements java.lang.Iterable<T> {}\n\nA quick-fix that renames such classes is available only in the editor.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/item/ItemBuilder.java",
      "language": "JAVA",
      "line": 33,
      "offset": 14,
      "length": 11,
      "code": {
        "startLine": 31,
        "length": 11,
        "offset": 31,
        "surroundingCode": " * @since 1.0\n */\npublic class ItemBuilder extends net.anweisen.utilities.bukkit.utils.item.ItemBuilder {\n\n\tpublic static final ItemStack BLOCKED_ITEM  = new ItemBuilder(Material.BARRIER, \"Â§cBlocked\").build();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ClassNameSameAsAncestorName"
  },
  "hash": "140c413ba104ad0c08e269e3029a87d2d23aaa6f377836e825b2e8c0996476a1"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Field can be made 'static'",
  "severity": "High",
  "comment": "Field `enabledByDefault` may be 'static'",
  "detailsInfo": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/type/abstraction/MenuSetting.java",
      "language": "JAVA",
      "line": 486,
      "offset": 25,
      "length": 16,
      "code": {
        "startLine": 484,
        "length": 16,
        "offset": 93,
        "surroundingCode": "\tpublic class NumberAndBooleanSubSetting extends NumberSubSetting {\n\n\t\tprivate final boolean enabledByDefault = false; // Implement in future\n\t\tprivate boolean enabled;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldMayBeStatic"
  },
  "hash": "6b4c698a85ba1a6eb9c4fc41b3238b34180d92bfb78d5be888bb51a13d6470c2"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Field can be made 'static'",
  "severity": "High",
  "comment": "Field `limit` may be 'static'",
  "detailsInfo": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/HydraPlusChallenge.java",
      "language": "JAVA",
      "line": 20,
      "offset": 12,
      "length": 5,
      "code": {
        "startLine": 18,
        "length": 5,
        "offset": 69,
        "surroundingCode": "public class HydraPlusChallenge extends HydraChallenge {\n\n\tfinal int limit = 512;\n\n\tpublic HydraPlusChallenge() {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldMayBeStatic"
  },
  "hash": "0eec6d9a445420c891d0fc511cebb341704b683a9c3be34d8c8bf29bad030551"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Field can be made 'static'",
  "severity": "High",
  "comment": "Field `duration` may be 'static'",
  "detailsInfo": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/TitleManager.java",
      "language": "JAVA",
      "line": 16,
      "offset": 32,
      "length": 8,
      "code": {
        "startLine": 14,
        "length": 8,
        "offset": 66,
        "surroundingCode": "public final class TitleManager {\n\n\tprivate final int fadein = 5, duration = 20, fadeout = 10;\n\n\tprivate final boolean timerStatusEnabled;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldMayBeStatic"
  },
  "hash": "c835bc21a638d1c8d78a8c756bee820c0d49ee29c0e2fcff03a7450db106ab47"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Field can be made 'static'",
  "severity": "High",
  "comment": "Field `fadeout` may be 'static'",
  "detailsInfo": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/TitleManager.java",
      "language": "JAVA",
      "line": 16,
      "offset": 47,
      "length": 7,
      "code": {
        "startLine": 14,
        "length": 7,
        "offset": 81,
        "surroundingCode": "public final class TitleManager {\n\n\tprivate final int fadein = 5, duration = 20, fadeout = 10;\n\n\tprivate final boolean timerStatusEnabled;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldMayBeStatic"
  },
  "hash": "2b35a455ad6ac9a2ca16aebf19fb753ad5c4fe21d9eba51b0c6058165b7b0205"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Field can be made 'static'",
  "severity": "High",
  "comment": "Field `fadein` may be 'static'",
  "detailsInfo": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/TitleManager.java",
      "language": "JAVA",
      "line": 16,
      "offset": 20,
      "length": 6,
      "code": {
        "startLine": 14,
        "length": 6,
        "offset": 54,
        "surroundingCode": "public final class TitleManager {\n\n\tprivate final int fadein = 5, duration = 20, fadeout = 10;\n\n\tprivate final boolean timerStatusEnabled;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldMayBeStatic"
  },
  "hash": "4febb8dafe4e9220eae611a07d59c933f049adc59cc756290a412e3c579de862"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Unnecessary semicolon",
  "severity": "High",
  "comment": "Unnecessary semicolon `;`",
  "detailsInfo": "Reports any unnecessary semicolons, including semicolons that are used between class members, inside block statements, or after class definitions.\n\nEven though these semicolons are valid in Java, they are redundant and may be removed.\n\nExample:\n\n\n      class C {\n        ;\n        void m() throws Exception {\n            try (AutoCloseable r1 = createAutoCloseable();) {\n              ;\n            }\n        }\n        ;\n      }\n\nAfter the quick-fix is applied:\n\n\n      class C {\n        void m() throws Exception {\n          try (AutoCloseable r1 = createAutoCloseable()) {\n          }\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/SettingType.java",
      "language": "JAVA",
      "line": 11,
      "offset": 9,
      "length": 1,
      "code": {
        "startLine": 9,
        "length": 1,
        "offset": 33,
        "surroundingCode": "  CONDITION,\n  MATERIAL,\n  ACTION;\n\n}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "UnnecessarySemicolon"
  },
  "hash": "a2f3dc7c2d35b3237e9d2f6ff42d441c58ed6bed577a697b516e039ee7145be3"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/ReloadCommand.java",
      "language": "JAVA",
      "line": 30,
      "offset": 7,
      "length": 15,
      "code": {
        "startLine": 28,
        "length": 15,
        "offset": 84,
        "surroundingCode": "\t\t\tBukkit.getPluginManager().enablePlugin(plugin);\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMessage.forName(\"reload-failed\").broadcast(Prefix.CHALLENGES);\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "c52da4a03a7377fc745c13f27cc546fdb5208c80aa9a45cc50b0d39e13c58ea2"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/LanguageLoader.java",
      "language": "JAVA",
      "line": 87,
      "offset": 9,
      "length": 15,
      "code": {
        "startLine": 85,
        "length": 15,
        "offset": 80,
        "surroundingCode": "\t\t\t\t\tverifyLanguage(language, file, name);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\tLogger.error(\"Could not download language for {}. {}: {}\", element, ex.getClass().getSimpleName(), ex.getMessage());\n\t\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "b0b894921d1d76e1160fe1af98701e196f9064fe7dcb6cda137ccb07df03a1b0"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/sub/impl/ModifierSetting.java",
      "language": "JAVA",
      "line": 93,
      "offset": 17,
      "length": 15,
      "code": {
        "startLine": 91,
        "length": 15,
        "offset": 181,
        "surroundingCode": "      Challenges.getInstance().getLogger().severe(\"Something went wrong while parsing the \"\n          + \"value of subsetting \" + getKey() + \" with value \" + value);\n      exception.printStackTrace();\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "b06e1c0fa533ddd02271a39e5c6aa872cd743c8bb28552369d34aa55781853ab"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/PotionEffectAction.java",
      "language": "JAVA",
      "line": 35,
      "offset": 19,
      "length": 15,
      "code": {
        "startLine": 33,
        "length": 15,
        "offset": 155,
        "surroundingCode": "      } catch (Exception exception) {\n        Challenges.getInstance().getLogger().severe(\"Error while adding potion effect to player\");\n        exception.printStackTrace();\n      }\n    }"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "e240a039b10bf8cff2fbccf9bc10bed1acf42551beb52fb4485e3104fbaef444"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MissingItemsChallenge.java",
      "language": "JAVA",
      "line": 202,
      "offset": 8,
      "length": 15,
      "code": {
        "startLine": 200,
        "length": 15,
        "offset": 97,
        "surroundingCode": "\t\t\t} catch (Exception ex) {\n\t\t\t\tinventory.setItem(slot, new ItemStack(Material.BARRIER));\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "34a8873ffa49cf23b4fbf281ff84f3e62e7e253113790e025b27aca2eef99bd8"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/FiveHundredBlocksChallenge.java",
      "language": "JAVA",
      "line": 154,
      "offset": 19,
      "length": 15,
      "code": {
        "startLine": 152,
        "length": 15,
        "offset": 153,
        "surroundingCode": "        plugin.getLogger().severe(\"Error while loading 500 Blocks Challenge, \"\n            + \"key '\" + key + \"' is not a valid uuid\");\n        exception.printStackTrace();\n      }\n    }"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "5f4c9f89f5656c9ca0b3c9c2de2ba622ba5f446da82a976ebf7364785c9ae710"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/files/ConfigManager.java",
      "language": "JAVA",
      "line": 63,
      "offset": 6,
      "length": 15,
      "code": {
        "startLine": 61,
        "length": 15,
        "offset": 177,
        "surroundingCode": "\t\t} catch (IOException | NullPointerException | InvalidConfigurationException e) {\n\t\t\tplugin.getLogger().severe(\"Error while checking missing keys in the current config\");\n\t\t\te.printStackTrace();\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "937c0db828ee7328800c2ac274a44736bdfde04cb178abcf78754a322adb61ae"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to `printStackTrace()` should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/challenges/CustomChallengesLoader.java",
      "language": "JAVA",
      "line": 77,
      "offset": 15,
      "length": 15,
      "code": {
        "startLine": 75,
        "length": 15,
        "offset": 195,
        "surroundingCode": "\t\t\t} catch (Exception exception) {\n\t\t\t\tChallenges.getInstance().getLogger().error(\"Something went wrong while initializing custom challenge {} :: {}\", key, exception.getMessage());\n\t\t\t\texception.printStackTrace();\n\t\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "15a205bde9adad60813e96f38cce4d2af38c0f65b88b61fbd95f482685732a5d"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment can be replaced with operator assignment",
  "severity": "High",
  "comment": "`count = count + itemStack.getAmount()` could be simplified to 'count += itemStack.getAmount()'",
  "detailsInfo": "Reports assignment operations which can be replaced by operator-assignment.\n\nCode using operator assignment is shorter and may be clearer.\n\n**Example:**\n\n      x = x + 3;\n      x = x / 3;\n\nAfter the quick fix is applied:\n\n      x += 3;\n      x /= 3;\n\n\nUse the **Ignore conditional operators** option to ignore `&&`\nand `||`. Replacing conditional operators with operator\nassignment would change the evaluation from lazy to eager, which may change the semantics of the expression.\n\n\nUse the **Ignore obscure operators** option to ignore `^` and `%`, which are less known.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/goal/MostEmeraldsGoal.java",
      "language": "JAVA",
      "line": 50,
      "offset": 70,
      "length": 37,
      "code": {
        "startLine": 48,
        "length": 37,
        "offset": 142,
        "surroundingCode": "\t\tint count = 0;\n\t\tfor (ItemStack itemStack : inventory.getContents()) {\n\t\t\tif (itemStack != null && itemStack.getType() == Material.EMERALD) count = count + itemStack.getAmount();\n\t\t}\n\t\tif (player.getItemOnCursor().getType() == Material.EMERALD) count += player.getItemOnCursor().getAmount();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ReplaceAssignmentWithOperatorAssignment"
  },
  "hash": "b9b47d20bae769d5f36cac2d45adc0bb2dcb02675c90e49d3e498b915332f458"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment can be replaced with operator assignment",
  "severity": "High",
  "comment": "`time = time + effect.getDuration()` could be simplified to 'time += effect.getDuration()'",
  "detailsInfo": "Reports assignment operations which can be replaced by operator-assignment.\n\nCode using operator assignment is shorter and may be clearer.\n\n**Example:**\n\n      x = x + 3;\n      x = x / 3;\n\nAfter the quick fix is applied:\n\n      x += 3;\n      x /= 3;\n\n\nUse the **Ignore conditional operators** option to ignore `&&`\nand `||`. Replacing conditional operators with operator\nassignment would change the evaluation from lazy to eager, which may change the semantics of the expression.\n\n\nUse the **Ignore obscure operators** option to ignore `^` and `%`, which are less known.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/FreezeChallenge.java",
      "language": "JAVA",
      "line": 73,
      "offset": 55,
      "length": 34,
      "code": {
        "startLine": 71,
        "length": 34,
        "offset": 107,
        "surroundingCode": "\t\tentity.removePotionEffect(PotionEffectType.SLOW);\n\n\t\tif (effect != null && effect.getAmplifier() == 255) time = time + effect.getDuration();\n\n\t\tentity.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, time, 255));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ReplaceAssignmentWithOperatorAssignment"
  },
  "hash": "b3915455050bb2cc04ba9d317a51e027b96ed1c1293923ab6d9e3b3b8ca01772"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment can be replaced with operator assignment",
  "severity": "High",
  "comment": "`currentCount = currentCount*2` could be simplified to 'currentCount \\*= 2'",
  "detailsInfo": "Reports assignment operations which can be replaced by operator-assignment.\n\nCode using operator assignment is shorter and may be clearer.\n\n**Example:**\n\n      x = x + 3;\n      x = x / 3;\n\nAfter the quick fix is applied:\n\n      x += 3;\n      x /= 3;\n\n\nUse the **Ignore conditional operators** option to ignore `&&`\nand `||`. Replacing conditional operators with operator\nassignment would change the evaluation from lazy to eager, which may change the semantics of the expression.\n\n\nUse the **Ignore obscure operators** option to ignore `^` and `%`, which are less known.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/HydraPlusChallenge.java",
      "language": "JAVA",
      "line": 36,
      "offset": 3,
      "length": 29,
      "code": {
        "startLine": 34,
        "length": 29,
        "offset": 112,
        "surroundingCode": "\t\tint currentCount = getGameStateData().getInt(entityType.name());\n\t\tif (currentCount == 0) currentCount = 1;\n\t\tcurrentCount = currentCount*2;\n\t\tgetGameStateData().set(entityType.name(), Math.min(currentCount, limit));\n\t\treturn currentCount;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ReplaceAssignmentWithOperatorAssignment"
  },
  "hash": "87c63490fe6ac741b7b989e35d918156119d59cd785a984f00dcf001edd49ea0"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "severity": "High",
  "comment": "`for` statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/PregameMovementSetting.java",
      "language": "JAVA",
      "line": 51,
      "offset": 3,
      "length": 3,
      "code": {
        "startLine": 49,
        "length": 3,
        "offset": 64,
        "surroundingCode": "\n\tprivate void findNearestBlock(@Nonnull Location location) {\n\t\tfor (; location.getBlockY() > 0 && location.getBlock().isPassable(); location.subtract(0, 1, 0));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "2cc50bf40f324fc8e2a02e14c788a05792d387cb8edf3328c332e7ed6c7617a7"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'SkullBuilder' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/item/ItemBuilder.java",
      "language": "JAVA",
      "line": 285,
      "offset": 10,
      "length": 12,
      "code": {
        "startLine": 283,
        "length": 12,
        "offset": 49,
        "surroundingCode": "\t\t@Deprecated\n\t\t@DeprecatedSince(\"2.0\")\n\t\tpublic SkullBuilder(@Nonnull String owner) {\n\t\t\tsuper(Material.PLAYER_HEAD);\n\t\t\tsetOwner(owner);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "656cf90941b0b1be343702596b6fac78b7c8ba84d6a5091444d00ecd18ef7e06"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'setOwner' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/item/ItemBuilder.java",
      "language": "JAVA",
      "line": 324,
      "offset": 35,
      "length": 8,
      "code": {
        "startLine": 322,
        "length": 8,
        "offset": 93,
        "surroundingCode": "\t\t@DeprecatedSince(\"2.0\")\n\t\t@ReplaceWith(\"setOwner(UUID)\")\n\t\tpublic ItemBuilder.SkullBuilder setOwner(@Nonnull String owner) {\n\t\t\tgetMeta().setOwner(owner);\n\t\t\treturn this;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "0c8aad1852eceb4d169ead061cea14f0097b735d10daaf1259dd45d3e4736516"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `latestVersion` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 30,
      "offset": 4,
      "length": 13,
      "code": {
        "startLine": 28,
        "length": 13,
        "offset": 171,
        "surroundingCode": "\t\t\tVersion plugin = Challenges.getInstance().getVersion();\n\t\t\tVersion config = Version.parse(Challenges.getInstance().getConfigDocument().getString(\"config-version\"));\n\t\t\tlatestVersion = Version.parse(response);\n\n\t\t\tif (latestVersion.isNewerThan(plugin)) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "3281f0779d6da676c88dacd7c716aaf609c700e6bb4ea4c1c5b4b882b92771fe"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `newestPluginVersion` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 34,
      "offset": 5,
      "length": 19,
      "code": {
        "startLine": 32,
        "length": 19,
        "offset": 149,
        "surroundingCode": "\t\t\tif (latestVersion.isNewerThan(plugin)) {\n\t\t\t\tLogger.info(\"A new version of Challenges is available: {}, you have {}\", latestVersion, plugin);\n\t\t\t\tnewestPluginVersion = false;\n\t\t\t}\n\t\t\tif (plugin.isNewerThan(config)) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "c8996854908aa8c0d0fc60acd48c62f2861963e8cd1052386b26edcf8b6f51ad"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `newestConfigVersion` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 38,
      "offset": 5,
      "length": 19,
      "code": {
        "startLine": 36,
        "length": 19,
        "offset": 134,
        "surroundingCode": "\t\t\tif (plugin.isNewerThan(config)) {\n\t\t\t\tLogger.info(\"A new version of the config (plugins/Challenges/config.yml) is available\");\n\t\t\t\tnewestConfigVersion = false;\n\t\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "4adbaad2c4fc10f47c2f63e7857ffb7c75fc923fb645f7535aecf8d0d7fc2c14"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `loaded` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/LanguageLoader.java",
      "language": "JAVA",
      "line": 137,
      "offset": 4,
      "length": 6,
      "code": {
        "startLine": 135,
        "length": 6,
        "offset": 9,
        "surroundingCode": "\t\t\t}\n\n\t\t\tloaded = true;\n\t\t\tLogger.info(\"Successfully loaded language '{}' from config file: {} message(s)\", language, messages);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "11f519963bcc60b74019e810f1e18fc4da0c39b76ba2ee899580e4f09bf1897b"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `inCanceling` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/CancelEventAction.java",
      "language": "JAVA",
      "line": 28,
      "offset": 5,
      "length": 11,
      "code": {
        "startLine": 26,
        "length": 11,
        "offset": 89,
        "surroundingCode": "  @Override\n  public void execute(Entity entity, Map<String, String[]> subActions) {\n    inCanceling = true;\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "4fe202fad8fa4b2c4bb7a97a42bfedf1a1f84968c4ce731fe53646567c712fe6"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `startedNewService` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/cloud/CloudSupportManager.java",
      "language": "JAVA",
      "line": 124,
      "offset": 5,
      "length": 17,
      "code": {
        "startLine": 122,
        "length": 17,
        "offset": 81,
        "surroundingCode": "\t\t\tif (startNewService && !startedNewService)\n\t\t\t\tsupport.startNewService();\n\t\t\t\tstartedNewService = true;\n\t\t} catch (NoClassDefFoundError ex) {\n\t\t\tLogger.error(\"Unable to set to ingame with cloud support '{}', missing dependencies\", type);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "0179df068f17754047a5c43cd77481da5c554bf0617be72dee8af01528abefc0"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `index` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/scoreboard/ChallengeScoreboard.java",
      "language": "JAVA",
      "line": 108,
      "offset": 73,
      "length": 5,
      "code": {
        "startLine": 106,
        "length": 5,
        "offset": 162,
        "surroundingCode": "\t\t\t\tplayer.setScoreboard(scoreboard = Bukkit.getScoreboardManager().getNewScoreboard());\n\n\t\t\tObjective objective = scoreboard.registerNewObjective(String.valueOf(index++), \"dummy\", String.valueOf(instance.getTitle()));\n\t\t\tint score = lines.size();\n\t\t\tfor (String line : lines) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "afa033f88931644a5d438e3a180371396eee46eb9c305c55aec2f44928eefa76"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `hasCheated` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 38,
      "offset": 3,
      "length": 10,
      "code": {
        "startLine": 36,
        "length": 10,
        "offset": 119,
        "surroundingCode": "\tpublic ServerManager() {\n\t\tDocument sessionConfig = Challenges.getInstance().getConfigManager().getSessionConfig();\n\t\thasCheated = sessionConfig.getBoolean(\"cheated\", hasCheated);\n\t\tisFresh = sessionConfig.getBoolean(\"fresh\", true);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "f7b5977f35da10931b4e18a4109a6c861d1f7a71d163f408c1ab5529a559352d"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `isFresh` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 39,
      "offset": 3,
      "length": 7,
      "code": {
        "startLine": 37,
        "length": 7,
        "offset": 157,
        "surroundingCode": "\t\tDocument sessionConfig = Challenges.getInstance().getConfigManager().getSessionConfig();\n\t\thasCheated = sessionConfig.getBoolean(\"cheated\", hasCheated);\n\t\tisFresh = sessionConfig.getBoolean(\"fresh\", true);\n\n\t\tDocument pluginConfig = Challenges.getInstance().getConfigDocument();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "122a5c2dc06c30c5a47dbd28fe66e97364362bee3a346f5e643324fb250e751f"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `isFresh` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 48,
      "offset": 3,
      "length": 7,
      "code": {
        "startLine": 46,
        "length": 7,
        "offset": 32,
        "surroundingCode": "\n\tpublic void setNotFresh() {\n\t\tisFresh = false;\n\t\tChallenges.getInstance().getConfigManager().getSessionConfig().set(\"fresh\", false);\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "0af89333ecf267d34031e77517fd71ea945a7e65a187b17d0b1046626f1bbe6f"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field `hasCheated` from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 53,
      "offset": 3,
      "length": 10,
      "code": {
        "startLine": 51,
        "length": 10,
        "offset": 34,
        "surroundingCode": "\n\tpublic void setHasCheated() {\n\t\thasCheated = true;\n\t\tChallenges.getInstance().getConfigManager().getSessionConfig().set(\"cheated\", true);\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "3a62b3cea5c4c6d0543acabd035b94b5b45850add3b64cbd553d67d6108bac89"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "severity": "High",
  "comment": "Contents of collection `data` are updated, but never queried",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/condition/impl/IntervallCondition.java",
      "language": "JAVA",
      "line": 49,
      "offset": 35,
      "length": 4,
      "code": {
        "startLine": 47,
        "length": 4,
        "offset": 114,
        "surroundingCode": "    long currentTime = Challenges.getInstance().getChallengeTimer().getTime();\n\n    HashMap<String, List<String>> data = new HashMap<>();\n    List<String> list = new LinkedList<>();\n    data.put(\"time\", list);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "a3507ffacfa7fdb2a4e37982af21a9e02bddf0388e1bde961b7e923ba33d93db"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both synchronized and unsynchronized contexts",
  "severity": "High",
  "comment": "Field `hidden` is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/ChallengeTimer.java",
      "language": "JAVA",
      "line": 32,
      "offset": 18,
      "length": 6,
      "code": {
        "startLine": 30,
        "length": 6,
        "offset": 85,
        "surroundingCode": "\tprivate boolean countingUp = true;\n\tprivate boolean paused = true;\n\tprivate boolean hidden = false;\n\tprivate boolean sentEmpty;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "7567a99e334c9a3069706099a981366a9c8decdc83485f9f7cf43698e825c5d6"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both synchronized and unsynchronized contexts",
  "severity": "High",
  "comment": "Field `countingUp` is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/ChallengeTimer.java",
      "language": "JAVA",
      "line": 30,
      "offset": 18,
      "length": 10,
      "code": {
        "startLine": 28,
        "length": 10,
        "offset": 42,
        "surroundingCode": "\n\tprivate long time = 0;\n\tprivate boolean countingUp = true;\n\tprivate boolean paused = true;\n\tprivate boolean hidden = false;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "faf1ddc04756c4959c242a666bb6dfd1895ae79cd2fdc830c97d3a2dee827476"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both synchronized and unsynchronized contexts",
  "severity": "High",
  "comment": "Field `time` is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/ChallengeTimer.java",
      "language": "JAVA",
      "line": 29,
      "offset": 15,
      "length": 4,
      "code": {
        "startLine": 27,
        "length": 4,
        "offset": 51,
        "surroundingCode": "public final class ChallengeTimer {\n\n\tprivate long time = 0;\n\tprivate boolean countingUp = true;\n\tprivate boolean paused = true;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "96e633d8df8d7f73e1147cf6b59333bce24e2f465c302ff5d96e4306d56618f1"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/misc/MapUtils.java",
      "language": "JAVA",
      "line": 45,
      "offset": 9,
      "length": 5,
      "code": {
        "startLine": 43,
        "length": 5,
        "offset": 94,
        "surroundingCode": "      try {\n        map.put(entry.getKey(), document.getStringArray(entry.getKey()));\n      } catch (Exception exception) { }\n    }\n    return map;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "3e7486399fe227f5fd1e40bfc2cdc623ee50912041313500e5cdadf2d0896880"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/TimeCommand.java",
      "language": "JAVA",
      "line": 129,
      "offset": 5,
      "length": 5,
      "code": {
        "startLine": 127,
        "length": 5,
        "offset": 45,
        "surroundingCode": "\t\ttry {\n\t\t\treturn Long.parseLong(input);\n\t\t} catch (NumberFormatException ex) { }\n\t\treturn -1;\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "8a137ba0d53c174c0a4e72ccce55b95afa1133345b1cb86c92d9a5f150ec52f8"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/ResetCommand.java",
      "language": "JAVA",
      "line": 55,
      "offset": 7,
      "length": 5,
      "code": {
        "startLine": 53,
        "length": 5,
        "offset": 55,
        "surroundingCode": "\t\t\t\ttry {\n\t\t\t\t\tseed = Long.parseLong(seedInput);\n\t\t\t\t} catch (NumberFormatException exception) {\n\t\t\t\t}\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "bc1547d7e73402e2a199386aa6946dc316b4378420fbc7596fe78ad1f750fa8e"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/RandomMobAction.java",
      "language": "JAVA",
      "line": 27,
      "offset": 11,
      "length": 5,
      "code": {
        "startLine": 25,
        "length": 5,
        "offset": 108,
        "surroundingCode": "        try {\n          entity.getLocation().getWorld().spawnEntity(entity.getLocation(), value);\n        } catch (Exception ex) { }\n        break;\n      }"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "5a0de5e98050fc3f39280be3415e09de88431c032b0faa85d599b3269399b664"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/condition/AbstractChallengeCondition.java",
      "language": "JAVA",
      "line": 70,
      "offset": 11,
      "length": 5,
      "code": {
        "startLine": 68,
        "length": 5,
        "offset": 164,
        "surroundingCode": "          builder.addSetting(type.name(), new ItemBuilder(spawnEgg, DefaultItem.getItemPrefix() + StringUtils\n              .getEnumName(type)).build());\n        } catch (Exception ex) { }\n      }\n    });"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "d49ee30ad783a0c0e49c60ae51ac1275ff6a377c137d34e52a4bf9dd787818f5"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/BackpackSetting.java",
      "language": "JAVA",
      "line": 120,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 118,
        "length": 5,
        "offset": 110,
        "surroundingCode": "\t\t\t\tItemStack item = document.getSerializable(key, ItemStack.class);\n\t\t\t\tinventory.setItem(index, item);\n\t\t\t} catch (Exception ex) {\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "5e98ec0f520e268d532630c1779a6c26d884e6ab62c72bfa38164f7d9b305ac3"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/HealthDisplaySetting.java",
      "language": "JAVA",
      "line": 140,
      "offset": 5,
      "length": 5,
      "code": {
        "startLine": 138,
        "length": 5,
        "offset": 39,
        "surroundingCode": "\t\ttry {\n\t\t\tobjective.unregister();\n\t\t} catch (Exception ex) {\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "3517dba447caa5981c459c58195536f3d008b6097211da3849f143e1f80e1785"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MobRandomizerChallenge.java",
      "language": "JAVA",
      "line": 202,
      "offset": 8,
      "length": 5,
      "code": {
        "startLine": 200,
        "length": 5,
        "offset": 66,
        "surroundingCode": "\t\t\t\t\ttry {\n\t\t\t\t\t\treturn world.getWaterAmbientSpawnLimit();\n\t\t\t\t\t} catch (Throwable ex) {}\n\t\t\t\t}\n\t\t\t\tcase WATER_ANIMAL:  return world.getWaterAnimalSpawnLimit();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "9b32fe80e26dfd307c75932ff9655e21f52a77187c3518098283897d49dbd631"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/scoreboard/ChallengeScoreboard.java",
      "language": "JAVA",
      "line": 142,
      "offset": 5,
      "length": 5,
      "code": {
        "startLine": 140,
        "length": 5,
        "offset": 65,
        "surroundingCode": "\t\t\tif (objective == null) return;\n\t\t\tobjective.unregister();\n\t\t} catch (Exception ex) {\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "afc268c3aa8da6e17fe4e0e96c07bc9dfe881722e0ed061d720c0af7a6f68948"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/WorldManager.java",
      "language": "JAVA",
      "line": 173,
      "offset": 5,
      "length": 5,
      "code": {
        "startLine": 171,
        "length": 5,
        "offset": 85,
        "surroundingCode": "\t\ttry {\n\t\t\tsessionConfig.set(\"level-name\", Bukkit.getWorlds().get(0).getName());\n\t\t} catch (Exception ex) {\n\t\t}\n\t\tsessionConfig.save();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "969f8babb589f37e2f192e13e94a2491df69aa413f45c07b138e3714954635e1"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty `catch` block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 123,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 121,
        "length": 5,
        "offset": 64,
        "surroundingCode": "\t\t\ttry {\n\t\t\t\tlocation.getWorld().dropItem(location, item);\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "91e12325d4c2e9536fbb48a303e4e59cf5758b3a2c1e1275dd1f67e7f29986f1"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "'protected' member in 'final' class",
  "severity": "High",
  "comment": "Class member declared `protected` in 'final' class",
  "detailsInfo": "Reports `protected` members in `final`classes.\n\nSince `final` classes cannot be inherited, marking the method as `protected`\nmay be confusing. It is better to declare such members as `private` or package-visible instead.\n\n**Example:**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\nAs shown in the example, a class can be marked as `final` explicitly or implicitly.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/LoaderRegistry.java",
      "language": "JAVA",
      "line": 99,
      "offset": 2,
      "length": 9,
      "code": {
        "startLine": 97,
        "length": 9,
        "offset": 5,
        "surroundingCode": "\t}\n\n\tprotected static void execute(@Nonnull Class<? extends ContentLoader> classOfLoader, @Nonnull Runnable action) {\n\t\ttry {\n\t\t\taction.run();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ProtectedMemberInFinalClass"
  },
  "hash": "6ec2e17ad666d2a4bb18b1cecd65fdeab020df0d836419213ddb56b8774fd1c1"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "'protected' member in 'final' class",
  "severity": "High",
  "comment": "Class member declared `protected` in 'final' class",
  "detailsInfo": "Reports `protected` members in `final`classes.\n\nSince `final` classes cannot be inherited, marking the method as `protected`\nmay be confusing. It is better to declare such members as `private` or package-visible instead.\n\n**Example:**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\nAs shown in the example, a class can be marked as `final` explicitly or implicitly.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/cloud/CloudSupportManager.java",
      "language": "JAVA",
      "line": 146,
      "offset": 2,
      "length": 9,
      "code": {
        "startLine": 144,
        "length": 9,
        "offset": 5,
        "surroundingCode": "\t}\n\n\tprotected boolean isEnabled() {\n\t\treturn support != null;\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ProtectedMemberInFinalClass"
  },
  "hash": "d354a7e6908eb44a45466ceb65fae1b86a59f82e5a3971c47269a7af3e2313ce"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `dropItem` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/misc/InventoryUtils.java",
      "language": "JAVA",
      "line": 143,
      "offset": 42,
      "length": 8,
      "code": {
        "startLine": 141,
        "length": 8,
        "offset": 139,
        "surroundingCode": "\n\tpublic static void dropItemByPlayer(@Nonnull Location location, @Nonnull ItemStack itemStack) {\n\t\tItem droppedItem = location.getWorld().dropItem(location.clone().add(0, 1.4, 0), itemStack);\n\t\tdroppedItem.setVelocity(location.getDirection().multiply(0.4));\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "80a0f7435996858ae29cdc39156dc30d63a3392a1719ddd5fb7548c27cdb5cc8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/HealCommand.java",
      "language": "JAVA",
      "line": 41,
      "offset": 71,
      "length": 8,
      "code": {
        "startLine": 39,
        "length": 8,
        "offset": 179,
        "surroundingCode": "\t\tfor (Player player : targets) {\n\t\t\tMessage.forName(\"command-heal-healed\").send(player, Prefix.CHALLENGES);\n\t\t\tplayer.setHealth(player.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue());\n\t\t\tplayer.setFoodLevel(20);\n\t\t\tplayer.setSaturation(20);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "864cd0a5ac06c8954d3d8b87630028ad6fd4c573b8e1b00013a0da985a23e9eb"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `args.length >= 2` is always `true`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/TimerCommand.java",
      "language": "JAVA",
      "line": 108,
      "offset": 14,
      "length": 16,
      "code": {
        "startLine": 106,
        "length": 16,
        "offset": 144,
        "surroundingCode": "\t\t} else if (args.length == 2 && \"mode\".equalsIgnoreCase(args[0])) {\n\t\t\treturn Utils.filterRecommendations(args[1], \"up\", \"down\");\n\t\t} else if (args.length >= 2 && \"set\".equalsIgnoreCase(args[0])) {\n\t\t\treturn StringUtils.isNumber(last) ? Utils.filterRecommendations(last, last + \"m\", last + \"h\", last + \"d\", last + \"w\") : last.isEmpty() ? Arrays.asList(\"10\", \"30\", \"60\", \"120\") :  Collections.singletonList(last);\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "5cc064d6bea1afcb9fa3173d251e1ab53e2b9c5ef39aaa7bc28a61ab62a6e45a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getAliases` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/HelpListener.java",
      "language": "JAVA",
      "line": 33,
      "offset": 84,
      "length": 10,
      "code": {
        "startLine": 31,
        "length": 10,
        "offset": 88,
        "surroundingCode": "\t\t}\n\n\t\tList<String> names = new ArrayList<>(Challenges.getInstance().getCommand(\"help\").getAliases());\n\t\tnames.add(\"help\");\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "e8c78c1ae4ca3277dc160696d6f7c341df76222033ea0311c701d8376707413f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `path` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/LanguageLoader.java",
      "language": "JAVA",
      "line": 43,
      "offset": 26,
      "length": 4,
      "code": {
        "startLine": 41,
        "length": 4,
        "offset": 135,
        "surroundingCode": "\t\t\tString path = config.getString(DIRECT_FILE_PATH);\n\t\t\tLogger.info(\"Using direct language file '{}'\", path);\n\t\t\treadLanguage(new File(path));\n\t\t\treturn;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "7b477143259ee2c0a792bba9eb1344a06c0f979d57e6c014a899d20e3d43ebb7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getDisplayName` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/sub/builder/ChooseItemSubSettingsBuilder.java",
      "language": "JAVA",
      "line": 50,
      "offset": 84,
      "length": 14,
      "code": {
        "startLine": 48,
        "length": 14,
        "offset": 176,
        "surroundingCode": "          ItemStack itemStack = getSettings().get(value);\n          if (itemStack != null) {\n            display.add(\"Â§7\" + getKeyTranslation() + \" \" + itemStack.getItemMeta().getDisplayName());\n\n          }"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "f0ac3709da3705075e7dec84579a7f1df5183efdd84eb8f662bc59d91c29c3b1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getDisplayName` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/sub/builder/ChooseMultipleItemSubSettingBuilder.java",
      "language": "JAVA",
      "line": 54,
      "offset": 89,
      "length": 14,
      "code": {
        "startLine": 52,
        "length": 14,
        "offset": 163,
        "surroundingCode": "          if (itemStack != null) {\n            if (firstDisplay == null) {\n              firstDisplay = \"Â§7\" + getKeyTranslation() + \" \" + itemStack.getItemMeta().getDisplayName();\n            } else {\n              count++;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "a4e39536ed7bc997296f84067eaba1446bf09ef2b509dd7d7fba265f504993a1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `spawnEntity` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/RandomMobAction.java",
      "language": "JAVA",
      "line": 26,
      "offset": 43,
      "length": 11,
      "code": {
        "startLine": 24,
        "length": 11,
        "offset": 89,
        "surroundingCode": "      if (value.isSpawnable()) {\n        try {\n          entity.getLocation().getWorld().spawnEntity(entity.getLocation(), value);\n        } catch (Exception ex) { }\n        break;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "96de456c0461996a30fe1086355f912804e09380001c381bbcaa31c03ed9d989"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getBaseValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/HealEntityAction.java",
      "language": "JAVA",
      "line": 33,
      "offset": 67,
      "length": 12,
      "code": {
        "startLine": 31,
        "length": 12,
        "offset": 192,
        "surroundingCode": "      LivingEntity livingEntity = (LivingEntity) entity;\n      double newHealth = Math.min(livingEntity.getHealth() + amount,\n          livingEntity.getAttribute(Attribute.GENERIC_MAX_HEALTH).getBaseValue());\n      livingEntity.setHealth(newHealth);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "6fd7c98ad047726e463e2fdd410a60a8592b3763e9cf1dcb57551874078738ba"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `createEffect` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/PotionEffectAction.java",
      "language": "JAVA",
      "line": 29,
      "offset": 42,
      "length": 12,
      "code": {
        "startLine": 27,
        "length": 12,
        "offset": 142,
        "surroundingCode": "\n        PotionEffectType effectType = PotionEffectType.getByName(subActions.get(\"potion_type\")[0]);\n        PotionEffect effect = effectType.createEffect(Integer.parseInt(subActions.get(\"length\")[0]) * 20 + 1,\n            Integer.parseInt(subActions.get(\"amplifier\")[0]));\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "955540c4f30761acd209f8343fcedd05473fe2f141e8fd78e0e639e8e8175571"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `createEffect` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/RandomPotionEffectAction.java",
      "language": "JAVA",
      "line": 29,
      "offset": 42,
      "length": 12,
      "code": {
        "startLine": 27,
        "length": 12,
        "offset": 87,
        "surroundingCode": "          .getNewRandomEffect(livingEntity);\n\n      PotionEffect effect = randomEffect.createEffect(Integer.parseInt(subActions.get(\"length\")[0]) * 20 + 1,\n          Integer.parseInt(subActions.get(\"amplifier\")[0]));\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "6e30c22d9de49f4b45c6db543e4d7aeea85f4f907e6f41be4b4c92420becad0d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `event.getTo()` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/condition/impl/StandsOnSpecificBlock.java",
      "language": "JAVA",
      "line": 30,
      "offset": 9,
      "length": 13,
      "code": {
        "startLine": 28,
        "length": 13,
        "offset": 129,
        "surroundingCode": "    if (BlockUtils.isSameBlock(event.getTo(), event.getFrom())) return;\n    Block blockBelow = BlockUtils.getBlockBelow(\n        event.getTo());\n    if (blockBelow == null) return;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "d83a5a8ac5d0339b4932aaed838b7bd83e5623fc358f26f5164d2de89e8f5c8e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `event.getTo()` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/condition/impl/StandsNotOnSpecificBlock.java",
      "language": "JAVA",
      "line": 33,
      "offset": 49,
      "length": 13,
      "code": {
        "startLine": 31,
        "length": 13,
        "offset": 121,
        "surroundingCode": "    if (BlockUtils.isSameBlock(event.getTo(), event.getFrom())) return;\n\n    Block blockBelow = BlockUtils.getBlockBelow(event.getTo());\n    if (blockBelow == null) return;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "baba67d8c4346637db819fafac7132cee7b5852b6f76443dbf6d29385cd125bd"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `slot <= 35` is always `true` when reached",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/SlotLimitSetting.java",
      "language": "JAVA",
      "line": 71,
      "offset": 28,
      "length": 10,
      "code": {
        "startLine": 69,
        "length": 10,
        "offset": 78,
        "surroundingCode": "\t\tif (slot >= 9 && slot <= 17) {\n\t\t\tslot += 9 * 2;\n\t\t} else if (slot >= 27 && slot <= 35) {\n\t\t\tslot -= 9 * 2;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "5a7c95b66a138457d218dbb383f3f630312dc7d96bccb7f1ef2e38514461ec2a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getMainScoreboard` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/HealthDisplaySetting.java",
      "language": "JAVA",
      "line": 110,
      "offset": 63,
      "length": 17,
      "code": {
        "startLine": 108,
        "length": 17,
        "offset": 113,
        "surroundingCode": "\n\t\tScoreboard scoreboard = player.getScoreboard();\n\t\tif (player.getScoreboard() == Bukkit.getScoreboardManager().getMainScoreboard())\n\t\t\tplayer.setScoreboard(scoreboard = Bukkit.getScoreboardManager().getNewScoreboard());\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "00f494b97ab00209ee78f712438b634920995c8769172935e6df55befae1df13"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Unboxing of `Bukkit.getWorlds().get(0).getGameRuleValue(GameRule.KEEP_INVENTORY)` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/KeepInventorySetting.java",
      "language": "JAVA",
      "line": 23,
      "offset": 15,
      "length": 67,
      "code": {
        "startLine": 21,
        "length": 67,
        "offset": 50,
        "surroundingCode": "\t\tsuper(MenuType.SETTINGS);\n\t\ttry {\n\t\t\tsetEnabled(Bukkit.getWorlds().get(0).getGameRuleValue(GameRule.KEEP_INVENTORY));\n\t\t} catch (Exception ignored) { }\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "c8e5e6edb835db314962e7fe88ccb74e0509e764a45a30dc08ac00ce4a5a480c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getDamage` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/LoopChallenge.java",
      "language": "JAVA",
      "line": 310,
      "offset": 69,
      "length": 9,
      "code": {
        "startLine": 308,
        "length": 9,
        "offset": 133,
        "surroundingCode": "\t\t\t\tif (item == null) continue;\n\t\t\t\tif (!isTool(item)) continue;\n\t\t\t\tif (((org.bukkit.inventory.meta.Damageable) item.getItemMeta()).getDamage() >= item.getType().getMaxDurability()) {\n\t\t\t\t\tplayer.getInventory().setItem(slot, null);\n\t\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "431d1f3718339a57686000f920286cd4ca93883b093885f067e640b21d0acc5a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `i == 1` is always `true`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/AnvilRainChallenge.java",
      "language": "JAVA",
      "line": 192,
      "offset": 16,
      "length": 6,
      "code": {
        "startLine": 190,
        "length": 6,
        "offset": 38,
        "surroundingCode": "\n\t\tif (i == 0) return;\n\t\tint blocks = i == 1 && getCount() < 16 ? 0 : 1;\n\t\twhile (blocks < 2 && origin.getBlockY() > 1) {\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "4120fbdb508920351c8100b7757886dcf7ca0525942e4ad3fe95f304ae1e0ec5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `setBaseValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/ZeroHeartsChallenge.java",
      "language": "JAVA",
      "line": 70,
      "offset": 73,
      "length": 12,
      "code": {
        "startLine": 68,
        "length": 12,
        "offset": 141,
        "surroundingCode": "\t@ScheduledTask(ticks = 20, async = false)\n\tpublic void onSecond() {\n\t\tbroadcast(player -> player.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(0));\n\t\tint absorptionTime = getCurrentTime();\n\t\tif (absorptionTime >= getValue() * 60) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "ff990af1856ee30ab55237d3ac5b3f3f011cfb04cdcc4fe6cb67142fc097800b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `setBaseValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/ZeroHeartsChallenge.java",
      "language": "JAVA",
      "line": 48,
      "offset": 97,
      "length": 12,
      "code": {
        "startLine": 46,
        "length": 12,
        "offset": 120,
        "surroundingCode": "\t\t});\n\t\tbossbar.show();\n\t\tBukkit.getOnlinePlayers().forEach(player -> player.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(0));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "d0e6de3dc8cb4fb25ea9914a8a43a2ed8cb8e271c1c6c7c304b6dd52fc1ac830"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getMaxHeight` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 176,
      "offset": 110,
      "length": 12,
      "code": {
        "startLine": 174,
        "length": 12,
        "offset": 252,
        "surroundingCode": "\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\tLocation randomLocation = player.getLocation().add(random.nextInt(10) - 5, -20, random.nextInt(10 - 5));\n\t\t\t\twhile (!randomLocation.getBlock().isPassable() && randomLocation.getBlockY() < randomLocation.getWorld().getMaxHeight())\n\t\t\t\t\trandomLocation.add(0, 1, 0);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "f45a9f8608386d91cbc2a0b1656e8e770755b18e450d6c23e6a322f58d1bcacc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getMaxHeight` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 118,
      "offset": 110,
      "length": 12,
      "code": {
        "startLine": 116,
        "length": 12,
        "offset": 271,
        "surroundingCode": "\t\t\tfor (int i = 0; i < random.nextInt(5) + 5; i++) {\n\t\t\t\tLocation randomLocation = player.getLocation().add(random.nextInt(10) - 5, -10, random.nextInt(10 - 5));\n\t\t\t\twhile (!randomLocation.getBlock().isPassable() && randomLocation.getBlockY() < randomLocation.getWorld().getMaxHeight())\n\t\t\t\t\trandomLocation.add(0, 1, 0);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "66c6c85e696eec4b4f7a133e67f822fb703ca4bcfe821f04b086f6ff8f572686"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `spawnEntity` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 121,
      "offset": 31,
      "length": 11,
      "code": {
        "startLine": 119,
        "length": 11,
        "offset": 65,
        "surroundingCode": "\t\t\t\t\trandomLocation.add(0, 1, 0);\n\n\t\t\t\trandomLocation.getWorld().spawnEntity(randomLocation, type);\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "af9c3c20c6ab1375a9cb549bfc844991910cb5c0938314dadc86f03eb6e67743"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `location.getWorld()` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 202,
      "offset": 56,
      "length": 19,
      "code": {
        "startLine": 200,
        "length": 19,
        "offset": 129,
        "surroundingCode": "\t\t\t\t\t\tint finalX = x;\n\t\t\t\t\t\tBukkit.getScheduler().runTask(plugin, () -> {\n\t\t\t\t\t\t\tfor (int y = BukkitReflectionUtils.getMinHeight(location.getWorld()); y < 80; y++) {\n\t\t\t\t\t\t\t\tLocation current = location.clone().add(finalX, 0, finalZ);\n\t\t\t\t\t\t\t\tcurrent.setY(y);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "b55d47772229017b89472decc08fd5a9c4d08d29f7784514b0876a05af1fcfbc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "The call to 'MenuClickInfo' always fails as an argument is out of bounds",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MissingItemsChallenge.java",
      "language": "JAVA",
      "line": 118,
      "offset": 40,
      "length": 13,
      "code": {
        "startLine": 116,
        "length": 13,
        "offset": 140,
        "surroundingCode": "\t\t\t\t\tcancel();\n\t\t\t\t\tTuple<Inventory, MenuPosition> tuple = inventories.remove(player.getUniqueId());\n\t\t\t\t\ttuple.getSecond().handleClick(new MenuClickInfo(player, tuple.getFirst(), false, false, -1));\n\t\t\t\t} else if (timeLeft <= 5) {\n\t\t\t\t\tnew SoundSample().addSound(Sound.BLOCK_NOTE_BLOCK_BASS, 0.5F, (float) (timeLeft - 1) / 10 + 1).play(player);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "abe1af71bc5b5fe509c6e814851db36269b9bd4492a18fbac1d1405cc62b3ee5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `setBaseValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomizedHPChallenge.java",
      "language": "JAVA",
      "line": 89,
      "offset": 55,
      "length": 12,
      "code": {
        "startLine": 87,
        "length": 12,
        "offset": 181,
        "surroundingCode": "\t\t\t\tdouble health = entityDefaultHealth.getOrDefault(type, getDefaultHealth(type));\n\t\t\t\tentityDefaultHealth.put(type, health);\n\t\t\t\tentity.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(health);\n\t\t\t\tentity.setHealth(health);\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "31a5305f6d4c92687772a43320d6e18bdad3f3d7f28482f705e895e96f79c131"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getBaseValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomizedHPChallenge.java",
      "language": "JAVA",
      "line": 100,
      "offset": 77,
      "length": 12,
      "code": {
        "startLine": 98,
        "length": 12,
        "offset": 146,
        "surroundingCode": "\t\tentity.remove();\n\t\tif (!(entity instanceof LivingEntity)) return 0;\n\t\treturn ((LivingEntity) entity).getAttribute(Attribute.GENERIC_MAX_HEALTH).getBaseValue();\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "8d5badb9a2de6795f92cf9192e3c1534f16e44cb8e322c7798aed4ee12eefecb"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `setBaseValue` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomizedHPChallenge.java",
      "language": "JAVA",
      "line": 69,
      "offset": 53,
      "length": 12,
      "code": {
        "startLine": 67,
        "length": 12,
        "offset": 109,
        "surroundingCode": "\t\t}\n\t\tint health = random.nextInt(getValue() * 100) + 1;\n\t\tentity.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(health);\n\t\tentity.setHealth(health);\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "096529edb13a9faea308b02e9012b13a6439efab506a913099cd5be7ab2312a4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getAmplifier` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/PermanentEffectOnDamageChallenge.java",
      "language": "JAVA",
      "line": 180,
      "offset": 15,
      "length": 12,
      "code": {
        "startLine": 178,
        "length": 12,
        "offset": 119,
        "surroundingCode": "\t\tif (player.hasPotionEffect(effectType)) {\n\t\t\tPotionEffect effect = player.getPotionEffect(effectType);\n\t\t\tif (effect.getAmplifier() == amplifier-1) {\n\t\t\t\treturn;\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "7c96b7a55078b69284120dc6b5fc80c08a930d17f0c049a8a5b7dfbad996f66e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `index >= array.length` is always `false`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/generator/ChooseItemGenerator.java",
      "language": "JAVA",
      "line": 54,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 52,
        "length": 21,
        "offset": 69,
        "surroundingCode": "\t\t\t\tString[] array = items.keySet().toArray(new String[0]);\n\n\t\t\t\tif (index >= array.length || isSideSlot(slot) || isTopOrBottomSlot(slot)) {\n\t\t\t\t\tSoundSample.CLICK.play(info.getPlayer());\n\t\t\t\t\treturn;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "73319b07d710bd8de22426d0a2b34e4fded7c55b0467f87949ae63930461a19b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `index >= array.length` is always `false`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/generator/ChooseMultipleItemGenerator.java",
      "language": "JAVA",
      "line": 71,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 69,
        "length": 21,
        "offset": 69,
        "surroundingCode": "\t\t\t\tString[] array = items.keySet().toArray(new String[0]);\n\n\t\t\t\tif (index >= array.length || isSideSlot(slot) || isTopOrBottomSlot(slot)) {\n\t\t\t\t\tSoundSample.CLICK.play(info.getPlayer());\n\t\t\t\t\treturn;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "76f116912b93d1fdbc5a1e1d7899c293c3a478f1667590dc95420f2a234ec4a6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `showPages && false` is always `false`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/InventoryTitleManager.java",
      "language": "JAVA",
      "line": 49,
      "offset": 63,
      "length": 18,
      "code": {
        "startLine": 47,
        "length": 18,
        "offset": 191,
        "surroundingCode": "\t@Nonnull\n\tpublic static String getMenuSettingTitle(@Nonnull MenuType menu, @Nonnull String name, int page, boolean showPages) {\n\t\treturn getTitle(\"Â§9\" + menu.getName() + \" Â§8â Â§9\" + name + (showPages && false /* temporarily disabled */ ? \" Â§8â¢ Â§9\" + (page + 1) : \"\"));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "ca4ebd18782a15c7188dde5be1af866b67b11267526cbe8865744b8fe3c6a6d3"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `plugin.getResource(\"config.yml\")` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/files/ConfigManager.java",
      "language": "JAVA",
      "line": 50,
      "offset": 17,
      "length": 32,
      "code": {
        "startLine": 48,
        "length": 32,
        "offset": 141,
        "surroundingCode": "\t\t\tFileOutputStream stream = new FileOutputStream(defaultConfigTempFile);\n\t\t\t// Copy the default config inside the temp file\n\t\t\tIOUtils.copy(plugin.getResource(\"config.yml\"), stream);\n\t\t\t// Load the File as a yaml config\n\t\t\t// Spigot Config Implementation because the Document Library does not contain deep-keys."
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "d4156db6192525af0597fbb96316cc10f161707b1cb22199703fdd06ebd53a73"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `result.getUUID(\"uuid\")` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/StatsManager.java",
      "language": "JAVA",
      "line": 135,
      "offset": 36,
      "length": 22,
      "code": {
        "startLine": 133,
        "length": 22,
        "offset": 110,
        "surroundingCode": "\t\t\t\t.execute().all()\n\t\t\t\t.filter(result -> result.getUUID(\"uuid\") != null)\n\t\t\t\t.map(result -> new PlayerStats(result.getUUID(\"uuid\"), result.getString(\"name\"), result.getDocument(\"stats\")))\n\t\t\t\t.collect(Collectors.toList());\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "e5cbf7c8b0831e2c129e31a749d6c49c6bce9234d67c767b8ea5e155fcad28fc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `result.getString(\"name\")` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/StatsManager.java",
      "language": "JAVA",
      "line": 135,
      "offset": 60,
      "length": 24,
      "code": {
        "startLine": 133,
        "length": 24,
        "offset": 134,
        "surroundingCode": "\t\t\t\t.execute().all()\n\t\t\t\t.filter(result -> result.getUUID(\"uuid\") != null)\n\t\t\t\t.map(result -> new PlayerStats(result.getUUID(\"uuid\"), result.getString(\"name\"), result.getDocument(\"stats\")))\n\t\t\t\t.collect(Collectors.toList());\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "f4d8fb720dee9f97f43bee4422f7f47495ae39073d300859daaed96b48c2507d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument `result.getString(\"name\")` might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/StatsManager.java",
      "language": "JAVA",
      "line": 114,
      "offset": 42,
      "length": 24,
      "code": {
        "startLine": 112,
        "length": 24,
        "offset": 89,
        "surroundingCode": "\t\t\t\t.where(\"uuid\", uuid)\n\t\t\t\t.execute().first()\n\t\t\t\t.map(result -> new PlayerStats(uuid, result.getString(\"name\"), result.getDocument(\"stats\")))\n\t\t\t\t.orElse(new PlayerStats(uuid, name));\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "da42f1de1a61c116914c6974966d9c7dc5777f5a511c8b222bc99225850a0425"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getLanguage` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/bstats/MetricsLoader.java",
      "language": "JAVA",
      "line": 24,
      "offset": 147,
      "length": 11,
      "code": {
        "startLine": 22,
        "length": 11,
        "offset": 195,
        "surroundingCode": "\n\t\tMetrics metrics = new Metrics(plugin, 11494);\n\t\tmetrics.addCustomChart(new SimplePie(\"language\", () -> Challenges.getInstance().getLoaderRegistry().getFirstLoaderByClass(LanguageLoader.class).getLanguage()));\n\t\tmetrics.addCustomChart(new SimplePie(\"cloudType\", () -> StringUtils.getEnumName(plugin.getCloudSupportManager().getType())));\n\t\tmetrics.addCustomChart(new SimplePie(\"databaseType\", () -> StringUtils.getEnumName(plugin.getDatabaseManager().getType())));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "ca6d77511361c9f27ac7ba7157ad35dc8f561d8c68c6908221eaaf87975afaf4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getMainScoreboard` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/scoreboard/ChallengeScoreboard.java",
      "language": "JAVA",
      "line": 105,
      "offset": 52,
      "length": 17,
      "code": {
        "startLine": 103,
        "length": 17,
        "offset": 103,
        "surroundingCode": "\n\t\t\tScoreboard scoreboard = player.getScoreboard();\n\t\t\tif (scoreboard == Bukkit.getScoreboardManager().getMainScoreboard())\n\t\t\t\tplayer.setScoreboard(scoreboard = Bukkit.getScoreboardManager().getNewScoreboard());\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "01f7db70dc57f711ef195657a90f9b096cd58e855a2d75ab84678c0333d83967"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Dereference of `source.list()` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/WorldManager.java",
      "language": "JAVA",
      "line": 293,
      "offset": 23,
      "length": 13,
      "code": {
        "startLine": 291,
        "length": 13,
        "offset": 65,
        "surroundingCode": "\t\tif (!target.exists())\n\t\t\ttarget.mkdir();\n\t\tfor (String child : source.list()) {\n\t\t\tif (\"session.lock\".equals(child)) continue;\n\t\t\tcopy(new File(source, child), new File(target, child));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "ecd84f25d47da82ce849bf721beb3d5908c14f6a81f52ff8e665dfa93c975da4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `getSpawnLocation` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/WorldManager.java",
      "language": "JAVA",
      "line": 213,
      "offset": 64,
      "length": 16,
      "code": {
        "startLine": 211,
        "length": 16,
        "offset": 117,
        "surroundingCode": "\n\t\t\tLocation location = player.getBedSpawnLocation();\n\t\t\tif (location == null) location = Bukkit.getWorld(levelName).getSpawnLocation();\n\n\t\t\tplayer.teleport(location);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "d9a489d29ecd9167338c8fb4e373a8a4380f27e9f093e1a1b661357009ef1346"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation `dropItem` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 122,
      "offset": 25,
      "length": 8,
      "code": {
        "startLine": 120,
        "length": 8,
        "offset": 34,
        "surroundingCode": "\n\t\t\ttry {\n\t\t\t\tlocation.getWorld().dropItem(location, item);\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "2b2126155f6ca3468e49e9cd2b6b4de03f3eaeaac348e4eec1788eb43089f9e2"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `found == null` is always `false`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/inventory/PlayerInventoryManager.java",
      "language": "JAVA",
      "line": 174,
      "offset": 8,
      "length": 13,
      "code": {
        "startLine": 172,
        "length": 13,
        "offset": 98,
        "surroundingCode": "\t\t\tif (expected != null && found == null) return false;\n\t\t\tif (expected == null) continue;\n\t\t\tif (found == null) continue;\n\t\t\tif (expected.getType() != found.getType()) return false;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "d21e80a17fa7660d0e465c848525dcceb2e050f2f1145f5ed6e71209fba6babe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition `time < 0` is always `false`",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/TimerFormat.java",
      "language": "JAVA",
      "line": 34,
      "offset": 7,
      "length": 8,
      "code": {
        "startLine": 32,
        "length": 8,
        "offset": 64,
        "surroundingCode": "\t@Nonnull\n\tpublic String format(@Nonnegative long time) {\n\t\tif (time < 0) time = 0;\n\n\t\tlong seconds = time;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "037ed5ee0a8412151f7f9cead359726b8e339f221b4e52c297fccbbe075a0396"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/HelpListener.java",
      "language": "JAVA",
      "line": 41,
      "offset": 42,
      "length": 2,
      "code": {
        "startLine": 39,
        "length": 2,
        "offset": 171,
        "surroundingCode": "\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"Â§7This server is running Â§eÂ§lChallenges Â§ev\" + Challenges.getInstance().getVersion());\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"\");\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"Â§7Made by Â§eCodingArea Â§8(Â§eanweisen Â§7& Â§eKxmischesDomiÂ§8)\");\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"Â§7Visit the source at Â§egithub.com/anweisen/Challenges\");"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "68800f285cce42260e16facd5d5f9802ecbe352e8ed896f0421eafecc0acfe8d"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/HealEntityAction.java",
      "language": "JAVA",
      "line": 22,
      "offset": 32,
      "length": 2,
      "code": {
        "startLine": 20,
        "length": 2,
        "offset": 119,
        "surroundingCode": "      String prefix = DefaultItem.getItemPrefix();\n      for (int i = 1; i < 21; i++) {\n        builder.addSetting(i + \"\", new ItemBuilder(Material.RED_DYE, prefix + \"Â§7\" + (i / 2f) + \" Â§câ¤\").setAmount(i).build());\n      }\n    }));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "1c21330025895ac81a821af3fe36805ce0b7d8821ac0d798e6cbf02c347fc051"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/DamageEntityAction.java",
      "language": "JAVA",
      "line": 21,
      "offset": 32,
      "length": 2,
      "code": {
        "startLine": 19,
        "length": 2,
        "offset": 119,
        "surroundingCode": "      String prefix = DefaultItem.getItemPrefix();\n      for (int i = 1; i < 21; i++) {\n        builder.addSetting(i + \"\", new ItemBuilder(Material.FERMENTED_SPIDER_EYE, prefix + \"Â§7\" + (i / 2f) + \" Â§câ¤\").setAmount(i).build());\n      }\n    }));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "5961ef249ad7e675edbd33904a2d4bfd82c1828456cea5c04c58ce987d960839"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/HungerPlayerAction.java",
      "language": "JAVA",
      "line": 22,
      "offset": 36,
      "length": 2,
      "code": {
        "startLine": 20,
        "length": 2,
        "offset": 77,
        "surroundingCode": "\n          for (int i = 1; i < 21; i++) {\n            builder.addSetting(i + \"\", new ItemBuilder(Material.ROTTEN_FLESH, prefix + \"Â§7\" + i).setAmount(i).build());\n          }\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "4f7a6eb6d9ccb8b9896a828f45a0188c8b0ddd6b67fdd84ad01fc632b9f81ac3"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/BackpackSetting.java",
      "language": "JAVA",
      "line": 142,
      "offset": 21,
      "length": 2,
      "code": {
        "startLine": 140,
        "length": 2,
        "offset": 112,
        "surroundingCode": "\t\tfor (int i = 0; i < inventory.getSize(); i++) {\n\t\t\tItemStack item = inventory.getItem(i);\n\t\t\tdocument.set(i + \"\", item);\n\t\t}\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "9c37a7dcba61b715942af7c5389ffd4e5a539a891299e19617234a6ee61bd536"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/PositionSetting.java",
      "language": "JAVA",
      "line": 299,
      "offset": 45,
      "length": 2,
      "code": {
        "startLine": 297,
        "length": 2,
        "offset": 51,
        "surroundingCode": "\t\t\t\t}\n\n\t\t\t\treturn Collections.singletonList(cord + \"\");\n\n\t\t\t} else if (args.length > 1) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "797bafdcf8f70d19bf36062c9480a50171db5386bbac3dbd1f147ac42de51a3f"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MaxHeightTimeChallenge.java",
      "language": "JAVA",
      "line": 101,
      "offset": 74,
      "length": 2,
      "code": {
        "startLine": 99,
        "length": 2,
        "offset": 128,
        "surroundingCode": "\n\tprivate int getCurrentTime(@Nonnull Player player) {\n\t\treturn getPlayerData(player).getInt(player.getLocation().getBlockY() + \"\", 0);\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "c7bd824cb1925bce6e6a1db8af9a7c3262c214d7237537f95ceedf4d6bf48912"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MaxHeightTimeChallenge.java",
      "language": "JAVA",
      "line": 95,
      "offset": 65,
      "length": 2,
      "code": {
        "startLine": 93,
        "length": 2,
        "offset": 100,
        "surroundingCode": "\t\t}\n\t\tif (time < getValue() * 60) {\n\t\t\tgetPlayerData(player).set(player.getLocation().getBlockY() + \"\", time);\n\t\t}\n\t\tbossbar.update(player);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "280704f34d52f94004c01688cc2e24afe371e47e29c934d765e7a7574adb9cf5"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/generator/implementation/custom/MainCustomMenuGenerator.java",
      "language": "JAVA",
      "line": 42,
      "offset": 54,
      "length": 2,
      "code": {
        "startLine": 40,
        "length": 2,
        "offset": 159,
        "surroundingCode": "\tprotected String getTitle(int page) {\n\t\treturn page != 0 ? InventoryTitleManager.getTitle(getMenuType(),\n\t\t\t\tMessage.forName(\"custom-title-view\").asString(), \"\" + page) :\n\t\t\t\tInventoryTitleManager.getTitle(getMenuType(), \"Menu\");\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "d2d5f8ba7fcb560df1ddcabaa2de156448a85e8cb8fd499982cb967be378750e"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/InventoryTitleManager.java",
      "language": "JAVA",
      "line": 25,
      "offset": 48,
      "length": 2,
      "code": {
        "startLine": 23,
        "length": 2,
        "offset": 124,
        "surroundingCode": "\t@Nonnull\n\tpublic static String getTitle(@Nonnull MenuType menu, int page) {\n\t\treturn getTitle(menu.getName(), (page + 1) + \"\");\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "cf94cbcd278115aa9c45bbabdb7d53f27dfa1ee9248a27b1750a41379d888854"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/Statistic.java",
      "language": "JAVA",
      "line": 39,
      "offset": 63,
      "length": 2,
      "code": {
        "startLine": 37,
        "length": 2,
        "offset": 138,
        "surroundingCode": "\n\t\tHEARTS(value ->  NumberFormatter.BIG_NUMBER.format(value / 2) + \" Â§câ¤\"),\n\t\tINTEGER(value -> NumberFormatter.BIG_NUMBER.format(value) + \"\");\n\n\t\tprivate final Function<Double, String> chatFormat;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "91162241cbb12f3cefce730b83c27caa5c4789cec4813d4e82e39c1d71d1fabe"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/bstats/MetricsLoader.java",
      "language": "JAVA",
      "line": 32,
      "offset": 26,
      "length": 2,
      "code": {
        "startLine": 30,
        "length": 2,
        "offset": 147,
        "surroundingCode": "\t\t\tHashMap<String, Integer> map = new HashMap<>();\n\t\t\tif (Runtime.getRuntime().maxMemory() == Long.MAX_VALUE) return map;\n\t\t\tmap.put(getMemory() + \"\", 1);\n\t\t\treturn map;\n\t\t}));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "9d53bb34c4d8243e20a56c56acfa5cf230f51320be1740962ee1764cb4792430"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 93,
      "offset": 92,
      "length": 2,
      "code": {
        "startLine": 91,
        "length": 2,
        "offset": 293,
        "surroundingCode": "\t\tString winnerString = StringUtils.getIterableAsString(winners, \"Â§7, \", player -> \"Â§eÂ§l\" + NameHelper.getName(player));\n\t\tString time = Challenges.getInstance().getChallengeTimer().getFormattedTime();\n\t\tString seed = Bukkit.getWorlds().isEmpty() ? \"?\" : Bukkit.getWorlds().get(0).getSeed() + \"\";\n\t\tendCause.getMessage(!winners.isEmpty()).broadcast(Prefix.CHALLENGES, time, winnerString, seed);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "be1dd071e40946fb5d2e0fe23281d3435d2389d69fa2ec7ef85208bfff6226dd"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/TimerFormat.java",
      "language": "JAVA",
      "line": 73,
      "offset": 23,
      "length": 2,
      "code": {
        "startLine": 71,
        "length": 2,
        "offset": 74,
        "surroundingCode": "\n\tprivate String digit2(@Nonnegative long number) {\n\t\treturn number > 9 ? \"\" + number : \"0\" + number;\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "92f3e1160b51ba5743041662c2783bb97b4c714cd60c7a31445699b98d811400"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/TimerFormat.java",
      "language": "JAVA",
      "line": 46,
      "offset": 21,
      "length": 2,
      "code": {
        "startLine": 44,
        "length": 2,
        "offset": 62,
        "surroundingCode": "\n\t\treturn getFormat(minutes, hours, days)\n\t\t\t\t.replace(\"{d}\", \"\" + days)\n\t\t\t\t.replace(\"{dd}\", digit2(days))\n\t\t\t\t.replace(\"{h}\", \"\" + hours)"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "6e13327503808c972e949742f3b4e722e30ea41c47f36b59258d9ca6ee26bf6e"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/TimerFormat.java",
      "language": "JAVA",
      "line": 48,
      "offset": 21,
      "length": 2,
      "code": {
        "startLine": 46,
        "length": 2,
        "offset": 86,
        "surroundingCode": "\t\t\t\t.replace(\"{d}\", \"\" + days)\n\t\t\t\t.replace(\"{dd}\", digit2(days))\n\t\t\t\t.replace(\"{h}\", \"\" + hours)\n\t\t\t\t.replace(\"{hh}\", digit2(hours))\n\t\t\t\t.replace(\"{m}\", \"\" + minutes)"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "48a188c44661ce3358dab002cdb7656c9e8479b23cb1c4522b59105e24592be5"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/TimerFormat.java",
      "language": "JAVA",
      "line": 50,
      "offset": 21,
      "length": 2,
      "code": {
        "startLine": 48,
        "length": 2,
        "offset": 88,
        "surroundingCode": "\t\t\t\t.replace(\"{h}\", \"\" + hours)\n\t\t\t\t.replace(\"{hh}\", digit2(hours))\n\t\t\t\t.replace(\"{m}\", \"\" + minutes)\n\t\t\t\t.replace(\"{mm}\", digit2(minutes))\n\t\t\t\t.replace(\"{s}\", \"\" + seconds)"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "b7266b1ea425a7f9a4d87ad036acadd5c845a13e47cedcf0b02231dff99b32c1"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/TimerFormat.java",
      "language": "JAVA",
      "line": 52,
      "offset": 21,
      "length": 2,
      "code": {
        "startLine": 50,
        "length": 2,
        "offset": 92,
        "surroundingCode": "\t\t\t\t.replace(\"{m}\", \"\" + minutes)\n\t\t\t\t.replace(\"{mm}\", digit2(minutes))\n\t\t\t\t.replace(\"{s}\", \"\" + seconds)\n\t\t\t\t.replace(\"{ss}\", digit2(seconds));\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "d006ce2798241355d0492f7e7f5b61cc6d734c4c0ddf137a8a78caaf336752bf"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `HoleEvent` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 127,
      "offset": 15,
      "length": 9,
      "code": {
        "startLine": 125,
        "length": 9,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class HoleEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "723360f8f2c0b70555e8553fe0544fdd2dc99daed60e7ea68cb599df663a6d71"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `ReplaceOresEvent` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 185,
      "offset": 15,
      "length": 16,
      "code": {
        "startLine": 183,
        "length": 16,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class ReplaceOresEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "fb16da033f8b868f152213921fbd7e62b64bcd32c6ac36c9b97c08754d463bdd"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `SicknessEvent` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 219,
      "offset": 15,
      "length": 13,
      "code": {
        "startLine": 217,
        "length": 13,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class SicknessEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "76b962d5a9db0484d60f04bcba7ea9217581accaac9e4488587762b0c91904c6"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `SpeedEvent` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 89,
      "offset": 15,
      "length": 10,
      "code": {
        "startLine": 87,
        "length": 10,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class SpeedEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "842860cdc82066aef0c5704228694819c756fa4aeea37569619e04ef00450ae6"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `FlyEvent` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 149,
      "offset": 15,
      "length": 8,
      "code": {
        "startLine": 147,
        "length": 8,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class FlyEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "1cf7c39613a6c102cbe45fcdecd20e1926d06089fa5117be37da2a7db214f49e"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `BossBarInstance` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/scoreboard/ChallengeBossBar.java",
      "language": "JAVA",
      "line": 22,
      "offset": 21,
      "length": 15,
      "code": {
        "startLine": 20,
        "length": 15,
        "offset": 59,
        "surroundingCode": "public final class ChallengeBossBar {\n\n\tpublic final class BossBarInstance {\n\n\t\tprivate String title = \"\";"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "58fb9922189d03c26d2ab20acc31ce6fedff3975b223fb6e994cb46423ce21f9"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class `ScoreboardInstance` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/scoreboard/ChallengeScoreboard.java",
      "language": "JAVA",
      "line": 27,
      "offset": 21,
      "length": 18,
      "code": {
        "startLine": 25,
        "length": 18,
        "offset": 52,
        "surroundingCode": "\tprivate static int index = 0;\n\n\tpublic final class ScoreboardInstance {\n\n\t\tprivate final String[] lines = new String[15];"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "776c219a247527ac95ca02f108af7359e6699da4ff45be38776b43f873993ebe"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class `SettingModifierGoal` has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/type/abstraction/SettingModifierGoal.java",
      "language": "JAVA",
      "line": 17,
      "offset": 23,
      "length": 19,
      "code": {
        "startLine": 15,
        "length": 19,
        "offset": 40,
        "surroundingCode": " * @since 2.0\n */\npublic abstract class SettingModifierGoal extends SettingModifier implements IGoal {\n\n\tpublic SettingModifierGoal(@Nonnull MenuType menu) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "f00ee143ccf1b48e5d4684a53c73ef485d4ead96be97fe37fe791fde43e08b5d"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Pointless statement or boolean expression",
  "severity": "High",
  "comment": "`showPages && false` can be simplified to 'false'",
  "detailsInfo": "Reports unnecessary or overly complicated boolean expressions.\n\nSuch expressions include `&&`-ing with `true`,\n`||`-ing with `false`,\nequality comparison with a boolean literal, or negation of a boolean literal. Such expressions can be simplified.\n\nExample:\n\n\n      boolean a = !(x && false);\n      boolean b = false || x;\n      boolean c = x != true;\n\nAfter the quick-fix is applied:\n\n\n      boolean a = true;\n      boolean b = x;\n      boolean c = !x;\n\n\nConfigure the inspection:\nUse the **Ignore named constants in determining pointless expressions** option to ignore named constants when determining if an expression is pointless.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/InventoryTitleManager.java",
      "language": "JAVA",
      "line": 49,
      "offset": 63,
      "length": 18,
      "code": {
        "startLine": 47,
        "length": 18,
        "offset": 191,
        "surroundingCode": "\t@Nonnull\n\tpublic static String getMenuSettingTitle(@Nonnull MenuType menu, @Nonnull String name, int page, boolean showPages) {\n\t\treturn getTitle(\"Â§9\" + menu.getName() + \" Â§8â Â§9\" + name + (showPages && false /* temporarily disabled */ ? \" Â§8â¢ Â§9\" + (page + 1) : \"\"));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "PointlessBooleanExpression"
  },
  "hash": "23daa3977c7fefdc31f86eb3950911753dca520c772a21f0cefb6c55a0116f89"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Result of method call ignored",
  "severity": "High",
  "comment": "Result of `File.mkdir()` is ignored",
  "detailsInfo": "Reports method calls whose result is ignored.\n\nFor many methods, ignoring the result is perfectly\nlegitimate, but for some it is almost certainly an error. Examples of methods where ignoring\nthe result is likely an error include `java.io.inputStream.read()`,\nwhich returns the number of bytes actually read, and any method on\n`java.lang.String` or `java.math.BigInteger`. These methods do not produce side-effects and thus pointless\nif their result is ignored.\n\nThe calls to the following methods are inspected:\n\n* Simple getters (which do nothing except return a field)\n* Methods specified in the settings of this inspection\n* Methods annotated with `org.jetbrains.annotations.Contract(pure=true)`\n* Methods annotated with .\\*.`CheckReturnValue`\n* Methods in a class or package annotated with `javax.annotation.CheckReturnValue`\n* Optionally, all non-library methods\n\nCalls to methods annotated with Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation are not reported.\n\n\nUse the inspection settings to specify the classes to check.\nMethods are matched by name or name pattern using Java regular expression syntax.\nFor classes, use fully-qualified names. Each entry applies to both the class and all its inheritors.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/WorldManager.java",
      "language": "JAVA",
      "line": 292,
      "offset": 11,
      "length": 5,
      "code": {
        "startLine": 290,
        "length": 5,
        "offset": 127,
        "surroundingCode": "\tprivate void copyDirectory(@Nonnull File source, @Nonnull File target) throws IOException {\n\t\tif (!target.exists())\n\t\t\ttarget.mkdir();\n\t\tfor (String child : source.list()) {\n\t\t\tif (\"session.lock\".equals(child)) continue;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "IgnoreResultOfCall"
  },
  "hash": "10a4db078481a7acd8ef37b6caa2ea304ccb895ae4457faf98fd8574916f0fdb"
}]}