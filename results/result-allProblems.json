{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Enum 'switch' statement that misses case",
  "severity": "High",
  "comment": "'switch (event.getAction()) { case LEFT_CLICK_AIR: case LEFT_CLICK_BLOCK: case PHYSICAL: ...' statement on enum type 'org.bukkit.event.block.Action' misses cases: 'RIGHT_CLICK_BLOCK', and 'RIGHT_CLICK_AIR'",
  "detailsInfo": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/inventory/PlayerInventoryManager.java",
      "language": "JAVA",
      "line": 86,
      "offset": 3,
      "length": 112,
      "code": {
        "startLine": 84,
        "length": 112,
        "offset": 79,
        "surroundingCode": "\t@EventHandler\n\tpublic void onInteract(@Nonnull PlayerInteractEvent event) {\n\t\tswitch (event.getAction()) {\n\t\t\tcase LEFT_CLICK_AIR:\n\t\t\tcase LEFT_CLICK_BLOCK:\n\t\t\tcase PHYSICAL:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (ChallengeAPI.isStarted()) return;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EnumSwitchStatementWhichMissesCases"
  },
  "hash": "e9966b1485b5dc943b7ed6838d58e0aed77af322b3723c1a2ac3b8058a1c9d73"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Enum 'switch' statement that misses case",
  "severity": "High",
  "comment": "'switch (this) { case AMBIENT: return world.getAmbientSpawnLimit(); case HOSTILE: r...' statement on enum type 'net.codingarea.challenges.plugin.challenges.implementation.challenge.MobRandomizerChallenge.EntityCategory' misses case 'OTHER'",
  "detailsInfo": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MobRandomizerChallenge.java",
      "language": "JAVA",
      "line": 195,
      "offset": 4,
      "length": 499,
      "code": {
        "startLine": 193,
        "length": 499,
        "offset": 56,
        "surroundingCode": "\n\t\tprivate int getSpawnLimit(@Nonnull World world) {\n\t\t\tswitch (this) {\n\t\t\t\tcase AMBIENT:\n\t\t\t\t\treturn world.getAmbientSpawnLimit();\n\t\t\t\tcase HOSTILE:\n\t\t\t\t\treturn world.getMonsterSpawnLimit();\n\t\t\t\tcase ANIMAL:\n\t\t\t\t\treturn world.getAnimalSpawnLimit();\n\t\t\t\tcase WATER_AMBIENT: { // getWaterAmbientSpawnLimit is not available in lower versions like 1.13, default to water animal then\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn world.getWaterAmbientSpawnLimit();\n\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase WATER_ANIMAL:\n\t\t\t\t\treturn world.getWaterAnimalSpawnLimit();\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EnumSwitchStatementWhichMissesCases"
  },
  "hash": "e89205a1ae73cf42c4a797a59e220c72a4f854f45d775faedfe739d6fd561b03"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Enum 'switch' statement that misses case",
  "severity": "High",
  "comment": "'switch (material) { case EMERALD_ORE: case DEEPSLATE_EMERALD_ORE: return 15; case DIAMO...' statement on enum type 'org.bukkit.Material' misses cases: 'AIR', 'STONE', 'GRANITE', 'POLISHED_GRANITE', ...",
  "detailsInfo": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/goal/MostOresGoal.java",
      "language": "JAVA",
      "line": 32,
      "offset": 3,
      "length": 453,
      "code": {
        "startLine": 30,
        "length": 453,
        "offset": 53,
        "surroundingCode": "\n\tprivate int getPointsForOre(Material material) {\n\t\tswitch (material) {\n\t\t\tcase EMERALD_ORE:\n\t\t\tcase DEEPSLATE_EMERALD_ORE:\n\t\t\t\treturn 15;\n\t\t\tcase DIAMOND_ORE:\n\t\t\tcase DEEPSLATE_DIAMOND_ORE:\n\t\t\t\treturn 10;\n\t\t\tcase LAPIS_ORE:\n\t\t\tcase DEEPSLATE_LAPIS_ORE:\n\t\t\t\treturn 8;\n\t\t\tcase GOLD_ORE:\n\t\t\tcase DEEPSLATE_GOLD_ORE:\n\t\t\t\treturn 6;\n\t\t\tcase IRON_ORE:\n\t\t\tcase DEEPSLATE_IRON_ORE:\n\t\t\t\treturn 4;\n\t\t\tcase COAL_ORE:\n\t\t\tcase DEEPSLATE_COAL_ORE:\n\t\t\tcase REDSTONE_ORE:\n\t\t\tcase DEEPSLATE_REDSTONE_ORE:\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EnumSwitchStatementWhichMissesCases"
  },
  "hash": "02bc0863853e62697a4a4345dc0fa6041ca6d2fce295de97b61bbeb2a475b3f1"
},{
  "tool": "Code Inspection",
  "category": "Class",
  "type": "Class name same as ancestor name",
  "severity": "High",
  "comment": "Class name 'ItemBuilder' is the same as one of its superclass' names",
  "detailsInfo": "Reports classes that have the same name as one of their superclasses, while their fully qualified names remain different. Such class names may be very confusing.\n\n**Example:**\n\n\n      package util;\n      abstract class Iterable<T> implements java.lang.Iterable<T> {}\n\nA quick-fix that renames such classes is available only in the editor.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/item/ItemBuilder.java",
      "language": "JAVA",
      "line": 33,
      "offset": 14,
      "length": 11,
      "code": {
        "startLine": 31,
        "length": 11,
        "offset": 31,
        "surroundingCode": " * @since 1.0\n */\npublic class ItemBuilder extends net.anweisen.utilities.bukkit.utils.item.ItemBuilder {\n\n\tpublic static final ItemStack BLOCKED_ITEM = new ItemBuilder(Material.BARRIER, \"Â§cBlocked\").build();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ClassNameSameAsAncestorName"
  },
  "hash": "ed5df42589bf56ea4f1e5ff3967b4b6b4b2f57f61945f2f64aefc0d9a677c843"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Field can be made 'static'",
  "severity": "High",
  "comment": "Field 'enabledByDefault' may be 'static'",
  "detailsInfo": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/type/abstraction/MenuSetting.java",
      "language": "JAVA",
      "line": 491,
      "offset": 25,
      "length": 16,
      "code": {
        "startLine": 489,
        "length": 16,
        "offset": 93,
        "surroundingCode": "\tpublic class NumberAndBooleanSubSetting extends NumberSubSetting {\n\n\t\tprivate final boolean enabledByDefault = false; // Implement in future\n\t\tprivate boolean enabled;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldMayBeStatic"
  },
  "hash": "be527d06402178225e370a39e954b03ce6e78880369e6a1378fd0153c76cbc2d"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "'if' statement with identical branches",
  "severity": "High",
  "comment": "Common part can be extracted removing branch",
  "detailsInfo": "Reports `if` statements in which common parts can be extracted from the branches.\n\nThese common parts are independent from the condition and make `if` statements harder to understand.\n\nExample:\n\n\n      if (x > 12) {\n        doSomethingBefore();\n        doSomethingDifferent1();\n        doSomethingAfter();\n      } else {\n        doSomethingBefore();\n        doSomethingDifferent2();\n        doSomethingAfter();\n      }\n\nAfter the quick-fix is applied:\n\n\n      doSomethingBefore();\n      if (x > 12) {\n        doSomethingDifferent1();\n      } else {\n        doSomethingDifferent2();\n      }\n      doSomethingAfter();\n\nUpdated in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/WorldManager.java",
      "language": "JAVA",
      "line": 215,
      "offset": 5,
      "length": 2,
      "code": {
        "startLine": 213,
        "length": 2,
        "offset": 77,
        "surroundingCode": "\t\t\tif (location == null) {\n\t\t\t\tWorld world = Bukkit.getWorld(levelName);\n\t\t\t\tif (world != null) {\n\t\t\t\t\tlocation = world.getSpawnLocation();\n\t\t\t\t} else {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "IfStatementWithIdenticalBranches"
  },
  "hash": "9c9d1acc91e829aca2102392ceddcbe6937441b36d6de96dd36507679f890ec6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "severity": "High",
  "comment": "'for' statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/PregameMovementSetting.java",
      "language": "JAVA",
      "line": 52,
      "offset": 3,
      "length": 3,
      "code": {
        "startLine": 50,
        "length": 3,
        "offset": 64,
        "surroundingCode": "\n\tprivate void findNearestBlock(@Nonnull Location location) {\n\t\tfor (; location.getBlockY() > 0 && location.getBlock().isPassable(); location.subtract(0, 1, 0))\n\t\t\t;\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "3f678d94e71949c9bdeb2b6d68928d6ea7244d5a853d69429d25fa82c80a3c1a"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MissingItemsChallenge.java",
      "language": "JAVA",
      "line": 200,
      "offset": 8,
      "length": 15,
      "code": {
        "startLine": 198,
        "length": 15,
        "offset": 97,
        "surroundingCode": "\t\t\t} catch (Exception ex) {\n\t\t\t\tinventory.setItem(slot, new ItemStack(Material.BARRIER));\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "7e935b5dbbfb24ac34f3893a246ea945d12562757a611fd72d9dbb8e7d811404"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/BackpackSetting.java",
      "language": "JAVA",
      "line": 124,
      "offset": 7,
      "length": 15,
      "code": {
        "startLine": 122,
        "length": 15,
        "offset": 89,
        "surroundingCode": "\t\t\t\tBukkitSerialization.fromBase64(inventory, value);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "32d2bd235cb73d31f9bce0a9ced3e83c018431819befa0efb85bfe0d79fd28d7"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/ReloadCommand.java",
      "language": "JAVA",
      "line": 29,
      "offset": 7,
      "length": 15,
      "code": {
        "startLine": 27,
        "length": 15,
        "offset": 84,
        "surroundingCode": "\t\t\tBukkit.getPluginManager().enablePlugin(plugin);\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMessage.forName(\"reload-failed\").broadcast(Prefix.CHALLENGES);\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "1f46f7a0b562053d3d7f23b7f24ce60b4a5cbceba043b8c16ca3650cbfa04831"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/database/DatabaseManager.java",
      "language": "JAVA",
      "line": 114,
      "offset": 16,
      "length": 15,
      "code": {
        "startLine": 112,
        "length": 15,
        "offset": 176,
        "surroundingCode": "\t\t\t\t} catch (Exception exception) {\n\t\t\t\t\tChallenges.getInstance().getLogger().error(\"Failed to create non existing column 'custom_challenges' in SQL Database\");\n\t\t\t\t\texception.printStackTrace();\n\t\t\t\t}\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "54177d9e9d172ae1cd5e63d1e32a6e362a77c3b432a3fcb1bfc6b7670c7e6fed"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/files/ConfigManager.java",
      "language": "JAVA",
      "line": 78,
      "offset": 6,
      "length": 15,
      "code": {
        "startLine": 76,
        "length": 15,
        "offset": 177,
        "surroundingCode": "\t\t} catch (IOException | NullPointerException | InvalidConfigurationException e) {\n\t\t\tplugin.getLogger().severe(\"Error while checking missing keys in the current config\");\n\t\t\te.printStackTrace();\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "124f165fe118f556709ceb258ac10633fdac50e92706a19176ac2df7299a74d1"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/LanguageLoader.java",
      "language": "JAVA",
      "line": 88,
      "offset": 9,
      "length": 15,
      "code": {
        "startLine": 86,
        "length": 15,
        "offset": 80,
        "surroundingCode": "\t\t\t\t\tverifyLanguage(language, file, name);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\tLogger.error(\"Could not download language for {}. {}: {}\", element, ex.getClass().getSimpleName(), ex.getMessage());\n\t\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "c7c7b2a18c52ebb471fa09ecf6703aacce1090fbfc55902e0f74ad72857abae2"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/sub/impl/ModifierSetting.java",
      "language": "JAVA",
      "line": 95,
      "offset": 14,
      "length": 15,
      "code": {
        "startLine": 93,
        "length": 15,
        "offset": 170,
        "surroundingCode": "\t\t\tChallenges.getInstance().getLogger().severe(\"Something went wrong while parsing the \"\n\t\t\t\t\t+ \"value of subsetting \" + getKey() + \" with value \" + value);\n\t\t\texception.printStackTrace();\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "092f055bd5e07c1ab9aa90d201600aca77ec53fa84d207cd583b7e414a29fbf1"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/GeneratorWorldPortalManager.java",
      "language": "JAVA",
      "line": 68,
      "offset": 15,
      "length": 15,
      "code": {
        "startLine": 66,
        "length": 15,
        "offset": 139,
        "surroundingCode": "\t\t\t} catch (Exception exception) {\n\t\t\t\tChallenges.getInstance().getLogger().error(\"Couldn't load last location of: \" + key);\n\t\t\t\texception.printStackTrace();\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "af4e7cd6b54287621a7f1cd5281196692bc7482deb3f3c9ba1ad3d4d0350d9ef"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/PotionEffectAction.java",
      "language": "JAVA",
      "line": 39,
      "offset": 15,
      "length": 15,
      "code": {
        "startLine": 37,
        "length": 15,
        "offset": 144,
        "surroundingCode": "\t\t\t} catch (Exception exception) {\n\t\t\t\tChallenges.getInstance().getLogger().severe(\"Error while adding potion effect to player\");\n\t\t\t\texception.printStackTrace();\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "dcf85f86cdb9b29113c57e276444909e8758b3c64de81dc8575d8ab3ccd72d75"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/FiveHundredBlocksChallenge.java",
      "language": "JAVA",
      "line": 181,
      "offset": 15,
      "length": 15,
      "code": {
        "startLine": 179,
        "length": 15,
        "offset": 139,
        "surroundingCode": "\t\t\t\tplugin.getLogger().severe(\"Error while loading 500 Blocks Challenge, \"\n\t\t\t\t\t\t+ \"key '\" + key + \"' is not a valid uuid\");\n\t\t\t\texception.printStackTrace();\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "e7509e0cb180816b676e42534cff3eb8ad65e8d5b6eb073ba841f451b0e16b88"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/challenges/CustomChallengesLoader.java",
      "language": "JAVA",
      "line": 76,
      "offset": 15,
      "length": 15,
      "code": {
        "startLine": 74,
        "length": 15,
        "offset": 195,
        "surroundingCode": "\t\t\t} catch (Exception exception) {\n\t\t\t\tChallenges.getInstance().getLogger().error(\"Something went wrong while initializing custom challenge {} :: {}\", key, exception.getMessage());\n\t\t\t\texception.printStackTrace();\n\t\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "1ad9f646a70a9a280d4c091b5f4961db567775a2b98aa8e8ca52e71dabc1aaab"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "'List.remove()' called in loop",
  "severity": "High",
  "comment": "Can be replaced with 'List.subList().clear()'",
  "detailsInfo": "Reports `List.remove(index)` called in a loop that can be replaced with `List.subList().clear()`.\n\nThe replacement\nis more efficient for most `List` implementations when many elements are deleted.\n\nExample:\n\n\n      void removeRange(List<String> list, int from, int to) {\n        for (int i = from; i < to; i++) {\n            list.remove(from);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void removeRange(List<String> list, int from, int to) {\n        if (to > from) {\n          list.subList(from, to).clear();\n        }\n      }\n\n\nThe quick-fix adds a range check automatically to prevent a possible `IndexOutOfBoundsException` when the minimal value is bigger\nthan the maximal value. It can be removed if such a situation is impossible in your code.\n\nNew in 2018.2",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/BackCommand.java",
      "language": "JAVA",
      "line": 68,
      "offset": 3,
      "length": 3,
      "code": {
        "startLine": 66,
        "length": 3,
        "offset": 25,
        "surroundingCode": "\t\tinTeleport = false;\n\n\t\tfor (int i = 0; i < countToTeleport; i++) {\n\t\t\tlist.remove(0);\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ListRemoveInLoop"
  },
  "hash": "289a658772bf216544ae8c2af6cfd59857881b3a5a29cb9738ac20d5cb28866f"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'entitiesKilled' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/type/abstraction/KillMobsGoal.java",
      "language": "JAVA",
      "line": 39,
      "offset": 3,
      "length": 14,
      "code": {
        "startLine": 37,
        "length": 14,
        "offset": 41,
        "surroundingCode": "\n\tprivate void resetEntitiesToKill() {\n\t\tentitiesKilled = new LinkedList<>();\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "119315b1aff56cd7b2e0658703dd7403fe2bf5aed3ddf618b6774bbc6a440da6"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'entitiesKilled' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/type/abstraction/KillMobsGoal.java",
      "language": "JAVA",
      "line": 91,
      "offset": 3,
      "length": 14,
      "code": {
        "startLine": 89,
        "length": 14,
        "offset": 36,
        "surroundingCode": "\t\tsuper.loadGameState(document);\n\n\t\tentitiesKilled = document.getEnumList(\"entities\", EntityType.class);\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "aade72772a5fdec89ed062e38cc9997b04ecff4ad1666b6f826becf9d0735174"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'maxCommandLength' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/ExecuteCommandAction.java",
      "language": "JAVA",
      "line": 44,
      "offset": 3,
      "length": 16,
      "code": {
        "startLine": 42,
        "length": 16,
        "offset": 43,
        "surroundingCode": "\t\t}));\n\t\t// Reload from config on reload\n\t\tmaxCommandLength = Challenges.getInstance().getConfigDocument().getInt(\"custom-challenge-settings.max-command-length\");\n\t\tcommandsThatCanBeExecuted = Challenges.getInstance().getConfigDocument().getStringList(\"custom-challenge-settings.allowed-commands-to-execute\");\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "c385d266e4c2d35374a88e6e7e75a813deb0f0aaf3888d391a3c3c7e989024d6"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'commandsThatCanBeExecuted' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/ExecuteCommandAction.java",
      "language": "JAVA",
      "line": 45,
      "offset": 3,
      "length": 25,
      "code": {
        "startLine": 43,
        "length": 25,
        "offset": 158,
        "surroundingCode": "\t\t// Reload from config on reload\n\t\tmaxCommandLength = Challenges.getInstance().getConfigDocument().getInt(\"custom-challenge-settings.max-command-length\");\n\t\tcommandsThatCanBeExecuted = Challenges.getInstance().getConfigDocument().getStringList(\"custom-challenge-settings.allowed-commands-to-execute\");\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "3a2475a1d5e963f1362975c649ea3212bc221d8c368b6b88c546ddc047b80343"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'inCanceling' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/action/impl/CancelEventAction.java",
      "language": "JAVA",
      "line": 29,
      "offset": 3,
      "length": 11,
      "code": {
        "startLine": 27,
        "length": 11,
        "offset": 108,
        "surroundingCode": "\t@Override\n\tpublic void execute(ChallengeExecutionData executionData, Map<String, String[]> subActions) {\n\t\tinCanceling = true;\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "5e77a7062a85310448e56e6306984a9cd1b4a05d35dcec243a2e8440fbd665b4"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'loaded' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/LanguageLoader.java",
      "language": "JAVA",
      "line": 138,
      "offset": 4,
      "length": 6,
      "code": {
        "startLine": 136,
        "length": 6,
        "offset": 9,
        "surroundingCode": "\t\t\t}\n\n\t\t\tloaded = true;\n\t\t\tLogger.info(\"Successfully loaded language '{}' from config file: {} message(s)\", language, messages);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "c248344beb7f14fb80bfa41e9248c57d868d7f1ec9865e2b8a65010d3771f2b6"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'defaultConfigVersion' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 31,
      "offset": 4,
      "length": 20,
      "code": {
        "startLine": 29,
        "length": 20,
        "offset": 163,
        "surroundingCode": "\t\t\tVersion plugin = Challenges.getInstance().getVersion();\n\t\t\tYamlConfiguration defaultConfig = Challenges.getInstance().getConfigManager().getDefaultConfig();\n\t\t\tdefaultConfigVersion = defaultConfig == null ? plugin : Version.parse(defaultConfig.getString(\"config-version\"));\n\t\t\tcurrentConfigVersion = Version.parse(Challenges.getInstance().getConfigDocument().getString(\"config-version\"));\n\t\t\tVersion latestVersion = Version.parse(response);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "99f5f35521ec329e48b2f64c88a0ef88a66e64edf56cfe54fae9e3c4c0c75b15"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'currentConfigVersion' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 32,
      "offset": 4,
      "length": 20,
      "code": {
        "startLine": 30,
        "length": 20,
        "offset": 221,
        "surroundingCode": "\t\t\tYamlConfiguration defaultConfig = Challenges.getInstance().getConfigManager().getDefaultConfig();\n\t\t\tdefaultConfigVersion = defaultConfig == null ? plugin : Version.parse(defaultConfig.getString(\"config-version\"));\n\t\t\tcurrentConfigVersion = Version.parse(Challenges.getInstance().getConfigDocument().getString(\"config-version\"));\n\t\t\tVersion latestVersion = Version.parse(response);\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "cb046667a1d9dcb18b3578f929626fb7497115ec3fdb33ab492242d248b23287"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'newestPluginVersion' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 37,
      "offset": 5,
      "length": 19,
      "code": {
        "startLine": 35,
        "length": 19,
        "offset": 149,
        "surroundingCode": "\t\t\tif (latestVersion.isNewerThan(plugin)) {\n\t\t\t\tLogger.info(\"A new version of Challenges is available: {}, you have {}\", latestVersion, plugin);\n\t\t\t\tnewestPluginVersion = false;\n\t\t\t}\n\t\t\tif (defaultConfigVersion.isNewerThan(currentConfigVersion)) {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "cd0ceaf9145ed7603d9a23e00ce94f6a5fd227b9f212dc0ba5f17698f5a88b09"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'newestConfigVersion' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/content/loader/UpdateLoader.java",
      "language": "JAVA",
      "line": 41,
      "offset": 5,
      "length": 19,
      "code": {
        "startLine": 39,
        "length": 19,
        "offset": 162,
        "surroundingCode": "\t\t\tif (defaultConfigVersion.isNewerThan(currentConfigVersion)) {\n\t\t\t\tLogger.info(\"A new version of the config (plugins/Challenges/config.yml) is available\");\n\t\t\t\tnewestConfigVersion = false;\n\t\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "ef1b37e7f3e1244de8e87bb5c4349f549b9a17481e5e210d61caf2b68275e159"
},{
  "tool": "Code Inspection",
  "category": "Assignment issues",
  "type": "Assignment to static field from instance context",
  "severity": "High",
  "comment": "Assignment to static field 'inputActions' from instance context",
  "detailsInfo": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/ChatInputListener.java",
      "language": "JAVA",
      "line": 24,
      "offset": 3,
      "length": 12,
      "code": {
        "startLine": 22,
        "length": 12,
        "offset": 33,
        "surroundingCode": "\n\tpublic ChatInputListener() {\n\t\tinputActions = new HashMap<>();\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "AssignmentToStaticFieldFromInstanceMethod"
  },
  "hash": "af6b499bcd68aa90c8c3d065e3df8845ac6d0dd9d900d46037d080338e709686"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'SkullBuilder' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/item/ItemBuilder.java",
      "language": "JAVA",
      "line": 285,
      "offset": 10,
      "length": 12,
      "code": {
        "startLine": 283,
        "length": 12,
        "offset": 49,
        "surroundingCode": "\t\t@Deprecated\n\t\t@DeprecatedSince(\"2.0\")\n\t\tpublic SkullBuilder(@Nonnull String owner) {\n\t\t\tsuper(Material.PLAYER_HEAD);\n\t\t\tsetOwner(owner);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "62d2ce693ce04bf2e3b5f8d5a22141694268d5fc6724ac341f86962a08f0a6d6"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated member is still used",
  "severity": "High",
  "comment": "Deprecated member 'setOwner' is still used",
  "detailsInfo": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/item/ItemBuilder.java",
      "language": "JAVA",
      "line": 324,
      "offset": 35,
      "length": 8,
      "code": {
        "startLine": 322,
        "length": 8,
        "offset": 93,
        "surroundingCode": "\t\t@DeprecatedSince(\"2.0\")\n\t\t@ReplaceWith(\"setOwner(UUID)\")\n\t\tpublic ItemBuilder.SkullBuilder setOwner(@Nonnull String owner) {\n\t\t\tgetMeta().setOwner(owner);\n\t\t\treturn this;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "DeprecatedIsStillUsed"
  },
  "hash": "bc50aad490c2c244afe1d8610de48e14142d9db74c314cb5864861439916a35c"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Commented out code",
  "severity": "Moderate",
  "comment": "Commented out code (7 lines)",
  "detailsInfo": "Reports comments that contain Java code.\n\nUsually, code that is commented out gets outdated very quickly and becomes misleading.\nAs most projects use some kind of version control system,\nit is better to delete commented out code completely and use the VCS history instead.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/CheatListener.java",
      "language": "JAVA",
      "line": 42,
      "offset": 1,
      "length": 2,
      "code": {
        "startLine": 40,
        "length": 2,
        "offset": 88,
        "surroundingCode": "\tpublic void onSneak(PlayerToggleSneakEvent event) {\n\t\tif (!event.isSneaking()) return;\n//\n//\t\tStructureManager manager = Bukkit.getStructureManager();\n//\t\tMap<NamespacedKey, Structure> structures = manager.getStructures();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CommentedOutCode"
  },
  "hash": "e5dc9a236dc79591eae237a15eb139c01de6ee054007fe2fdeea417790160e5e"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Commented out code",
  "severity": "Moderate",
  "comment": "Commented out code (6 lines)",
  "detailsInfo": "Reports comments that contain Java code.\n\nUsually, code that is commented out gets outdated very quickly and becomes misleading.\nAs most projects use some kind of version control system,\nit is better to delete commented out code completely and use the VCS history instead.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/generator/VoidMapGenerator.java",
      "language": "JAVA",
      "line": 61,
      "offset": 1,
      "length": 2,
      "code": {
        "startLine": 59,
        "length": 2,
        "offset": 125,
        "surroundingCode": "\tpublic ChunkData generateChunkData(@Nonnull World world, @Nonnull Random random, int x, int z, @Nonnull BiomeGrid biome) {\n\n//    if (portalChunks == null) {\n//      portalChunks = Lists.newLinkedList();\n//      Bukkit.getScheduler().runTask(Challenges.getInstance(), () -> {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CommentedOutCode"
  },
  "hash": "c6cdc008fd7a342ff15f697b5e16cce5428c08b3029f069a2feefad98c38172d"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Commented out code",
  "severity": "Moderate",
  "comment": "Commented out code (33 lines)",
  "detailsInfo": "Reports comments that contain Java code.\n\nUsually, code that is commented out gets outdated very quickly and becomes misleading.\nAs most projects use some kind of version control system,\nit is better to delete commented out code completely and use the VCS history instead.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/generator/VoidMapGenerator.java",
      "language": "JAVA",
      "line": 22,
      "offset": 1,
      "length": 2,
      "code": {
        "startLine": 20,
        "length": 2,
        "offset": 96,
        "surroundingCode": "\tprivate static final boolean generateEndPortal = MinecraftVersion.current().getMinor() == 18;\n\n//  private static class PortalInfo {\n//\n//    private final int chunkX;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CommentedOutCode"
  },
  "hash": "f0eb1bbca7cd8ae0723e680f49a70dc8c0db4c8b9326acdf0d94c3cdcef1fa5c"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both 'synchronized' and unsynchronized contexts",
  "severity": "High",
  "comment": "Field 'hidden' is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/ChallengeTimer.java",
      "language": "JAVA",
      "line": 34,
      "offset": 18,
      "length": 6,
      "code": {
        "startLine": 32,
        "length": 6,
        "offset": 85,
        "surroundingCode": "\tprivate boolean countingUp = true;\n\tprivate boolean paused = true;\n\tprivate boolean hidden = false;\n\tprivate boolean sentEmpty;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "cbfbc3a600672a630809d71fba4c8192397e07d84eaea5c61667d4c57835c10f"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both 'synchronized' and unsynchronized contexts",
  "severity": "High",
  "comment": "Field 'countingUp' is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/ChallengeTimer.java",
      "language": "JAVA",
      "line": 32,
      "offset": 18,
      "length": 10,
      "code": {
        "startLine": 30,
        "length": 10,
        "offset": 42,
        "surroundingCode": "\n\tprivate long time = 0;\n\tprivate boolean countingUp = true;\n\tprivate boolean paused = true;\n\tprivate boolean hidden = false;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "5db4e3194d990004eb52632ed1790bd482c98b8abb96bc9bf0836e402561eb27"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both 'synchronized' and unsynchronized contexts",
  "severity": "High",
  "comment": "Field 'time' is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/scheduler/timer/ChallengeTimer.java",
      "language": "JAVA",
      "line": 31,
      "offset": 15,
      "length": 4,
      "code": {
        "startLine": 29,
        "length": 4,
        "offset": 51,
        "surroundingCode": "public final class ChallengeTimer {\n\n\tprivate long time = 0;\n\tprivate boolean countingUp = true;\n\tprivate boolean paused = true;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "9a9de2c40f4b9f4c2b03870b514908b8fffb1bd2c8fe6a6706122f43e89269e5"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty 'catch' block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/command/ResetCommand.java",
      "language": "JAVA",
      "line": 68,
      "offset": 7,
      "length": 5,
      "code": {
        "startLine": 66,
        "length": 5,
        "offset": 55,
        "surroundingCode": "\t\t\t\ttry {\n\t\t\t\t\tseed = Long.parseLong(seedInput);\n\t\t\t\t} catch (NumberFormatException exception) {\n\t\t\t\t}\n\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "aa571480976a549e899debacbaa512c88bf990ca50849fe906857af341ea5712"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty 'catch' block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/setting/BackpackSetting.java",
      "language": "JAVA",
      "line": 137,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 135,
        "length": 5,
        "offset": 110,
        "surroundingCode": "\t\t\t\tItemStack item = document.getSerializable(key, ItemStack.class);\n\t\t\t\tinventory.setItem(index, item);\n\t\t\t} catch (Exception ex) {\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "17e186aefdcc0f9a5abf656bd45ad48bfcdce45c92c90c4793c863ebfb0a1466"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty 'catch' block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/utils/misc/MapUtils.java",
      "language": "JAVA",
      "line": 42,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 40,
        "length": 5,
        "offset": 84,
        "surroundingCode": "\t\t\ttry {\n\t\t\t\tmap.put(entry.getKey(), document.getStringArray(entry.getKey()));\n\t\t\t} catch (Exception exception) {\n\t\t\t}\n\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "3c432bd096bd33fbbfc9095b8f464f76428aaff11acbf16fc9a3fb8af279da64"
},{
  "tool": "Code Inspection",
  "category": "Error handling",
  "type": "Catch block may ignore exception",
  "severity": "High",
  "comment": "Empty 'catch' block",
  "detailsInfo": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/MobRandomizerChallenge.java",
      "language": "JAVA",
      "line": 205,
      "offset": 8,
      "length": 5,
      "code": {
        "startLine": 203,
        "length": 5,
        "offset": 66,
        "surroundingCode": "\t\t\t\t\ttry {\n\t\t\t\t\t\treturn world.getWaterAmbientSpawnLimit();\n\t\t\t\t\t} catch (Throwable ex) {\n\t\t\t\t\t}\n\t\t\t\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "CatchMayIgnoreException"
  },
  "hash": "1b7dda0eef440786bf0c4b923e8cd6488e1bf263e4c50d1ec76e2128a30abd68"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Unnecessary 'return' statement",
  "severity": "High",
  "comment": "'return' is unnecessary as the last statement in a 'void' method",
  "detailsInfo": "Reports `return` statements at the end of constructors and methods returning `void`. These statements are redundant and may be safely removed.\n\nThis inspection does not report in JSP files.\n\nExample:\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n        return;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n      }\n\n\nUse the **Ignore in then branch of 'if' statement with 'else' branch** option to ignore `return` statements in the then branch of `if` statements\nwhich also have an `else` branch.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/CheatListener.java",
      "language": "JAVA",
      "line": 41,
      "offset": 28,
      "length": 6,
      "code": {
        "startLine": 39,
        "length": 6,
        "offset": 129,
        "surroundingCode": "\t@EventHandler(priority = EventPriority.MONITOR)\n\tpublic void onSneak(PlayerToggleSneakEvent event) {\n\t\tif (!event.isSneaking()) return;\n//\n//\t\tStructureManager manager = Bukkit.getStructureManager();"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "UnnecessaryReturn"
  },
  "hash": "c7ef29ed8aca2ba4aa622fb2dba57e536a64a72d68698c90c01aa0336aad7934"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'event.getTo()' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/trigger/impl/StandsOnSpecificBlockTrigger.java",
      "language": "JAVA",
      "line": 31,
      "offset": 5,
      "length": 13,
      "code": {
        "startLine": 29,
        "length": 13,
        "offset": 129,
        "surroundingCode": "\t\tif (BlockUtils.isSameBlockLocation(event.getTo(), event.getFrom())) return;\n\t\tBlock blockBelow = BlockUtils.getBlockBelow(\n\t\t\t\tevent.getTo());\n\t\tif (blockBelow == null) return;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "073729852acec911d67d88a3854c53dbb699b0ecf06bf6208cdbb393bd4cf3bf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'event.getTo()' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/custom/settings/trigger/impl/StandsNotOnSpecificBlockTrigger.java",
      "language": "JAVA",
      "line": 35,
      "offset": 47,
      "length": 13,
      "code": {
        "startLine": 33,
        "length": 13,
        "offset": 125,
        "surroundingCode": "\t\tif (BlockUtils.isSameBlockLocation(event.getTo(), event.getFrom())) return;\n\n\t\tBlock blockBelow = BlockUtils.getBlockBelow(event.getTo());\n\t\tif (blockBelow == null) return;\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "f18dd0e986f247d829c0c1bee4325ba654b0b1c10e70340e34d0c3abe29ecd83"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition 'showPages && false' is always 'false'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/InventoryTitleManager.java",
      "language": "JAVA",
      "line": 50,
      "offset": 63,
      "length": 18,
      "code": {
        "startLine": 48,
        "length": 18,
        "offset": 191,
        "surroundingCode": "\t@Nonnull\n\tpublic static String getMenuSettingTitle(@Nonnull MenuType menu, @Nonnull String name, int page, boolean showPages) {\n\t\treturn getTitle(\"Â§9\" + menu.getName() + \" Â§8â Â§9\" + name + (showPages && false ? \" Â§8â¢ Â§9\" + (page + 1) : \"\"));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "ef8a3dd18411421ac0c18da6610df09a9dbb7c6333c16029de2bf47778d81ab4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation 'getHelmet' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/goal/ForceItemBattleGoal.java",
      "language": "JAVA",
      "line": 303,
      "offset": 48,
      "length": 9,
      "code": {
        "startLine": 301,
        "length": 9,
        "offset": 163,
        "surroundingCode": "\t\tarmorStand.teleport(player.getLocation().clone().add(0, 1.5, 0));\n\t\tarmorStand.setVelocity(player.getVelocity());\n\t\tItemStack helmet = armorStand.getEquipment().getHelmet();\n\t\tif (helmet == null || helmet.getType() != item) {\n\t\t\tarmorStand.getEquipment().setHelmet(new ItemStack(item));"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "1bdaaa12736731b7f13906452e43bd61f39db5b13f2cb0761f94a3fb0cbfa00d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'type.getEntityClass()' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/goal/KillAllMonsterGoal.java",
      "language": "JAVA",
      "line": 41,
      "offset": 57,
      "length": 21,
      "code": {
        "startLine": 39,
        "length": 21,
        "offset": 184,
        "surroundingCode": "\t\tLinkedList<EntityType> list = new LinkedList<>(Arrays.asList(EntityType.values()));\n\t\tlist.removeIf(type -> !type.isAlive());\n\t\tlist.removeIf(type -> !Monster.class.isAssignableFrom(type.getEntityClass()));\n\t\tlist.add(EntityType.PHANTOM);\n\t\tlist.add(EntityType.ENDER_DRAGON);"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "a26c185d5f7dbc230aa3b5f8f484cf1e2c6644f9667b5d506482549cb64d0deb"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Variable is already assigned to this value",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/CustomEventListener.java",
      "language": "JAVA",
      "line": 88,
      "offset": 4,
      "length": 9,
      "code": {
        "startLine": 86,
        "length": 9,
        "offset": 165,
        "surroundingCode": "\t\t} else if (!AbstractChallenge.ignoreGameMode(event.getNewGameMode()) && AbstractChallenge.ignoreGameMode(event.getPlayer().getGameMode())) {\n\t\t\texecute = true;\n\t\t\tisIgnored = false;\n\t\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "b29e1f95f62ed8703d66e8ef6cb326fffb204e5dd0fd43348ae395c5a7fb7f9e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'result.getString(\"name\")' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/StatsManager.java",
      "language": "JAVA",
      "line": 114,
      "offset": 42,
      "length": 24,
      "code": {
        "startLine": 112,
        "length": 24,
        "offset": 89,
        "surroundingCode": "\t\t\t\t.where(\"uuid\", uuid)\n\t\t\t\t.execute().first()\n\t\t\t\t.map(result -> new PlayerStats(uuid, result.getString(\"name\"), result.getDocument(\"stats\")))\n\t\t\t\t.orElse(new PlayerStats(uuid, name));\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "95e3b91e5b7c8b87d9edc93912e12b2a9087736801eb480f59bb49298eef6074"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'result.getUUID(\"uuid\")' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/StatsManager.java",
      "language": "JAVA",
      "line": 135,
      "offset": 36,
      "length": 22,
      "code": {
        "startLine": 133,
        "length": 22,
        "offset": 110,
        "surroundingCode": "\t\t\t\t.execute().all()\n\t\t\t\t.filter(result -> result.getUUID(\"uuid\") != null)\n\t\t\t\t.map(result -> new PlayerStats(result.getUUID(\"uuid\"), result.getString(\"name\"), result.getDocument(\"stats\")))\n\t\t\t\t.collect(Collectors.toList());\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "6e1dc2003bfb08001d39ea92cfd56c28382ffa9c3d120b200769ba48d7c60d89"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'result.getString(\"name\")' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/stats/StatsManager.java",
      "language": "JAVA",
      "line": 135,
      "offset": 60,
      "length": 24,
      "code": {
        "startLine": 133,
        "length": 24,
        "offset": 134,
        "surroundingCode": "\t\t\t\t.execute().all()\n\t\t\t\t.filter(result -> result.getUUID(\"uuid\") != null)\n\t\t\t\t.map(result -> new PlayerStats(result.getUUID(\"uuid\"), result.getString(\"name\"), result.getDocument(\"stats\")))\n\t\t\t\t.collect(Collectors.toList());\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "96fe8e432a2542f277ec77f10752da54b3c0bbf03709b93c62b856c07d8cae66"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation 'getItemInMainHand' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/BlockMobsChallenge.java",
      "language": "JAVA",
      "line": 50,
      "offset": 92,
      "length": 17,
      "code": {
        "startLine": 48,
        "length": 17,
        "offset": 165,
        "surroundingCode": "\t\t\t\t.spawnEntity(event.getBlock().getLocation().add(0.5, 0, 0.5), type);\n\n\t\tCollection<ItemStack> drops = event.getBlock().getDrops(event.getPlayer().getEquipment().getItemInMainHand());\n\n\t\tint i = 0;"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "debde50fbced7611b1761610bbd8d062756ad29293cb9a667e6207a5c9e45ea9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation 'setHelmetDropChance' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/BlockMobsChallenge.java",
      "language": "JAVA",
      "line": 61,
      "offset": 16,
      "length": 19,
      "code": {
        "startLine": 59,
        "length": 19,
        "offset": 43,
        "surroundingCode": "\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tequipment.setHelmetDropChance(1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "2abac754cb611e7cce1cd5390e7a7e11bab3791da89313cd326575739830ea1d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Method invocation 'setBaseValue' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomizedHPChallenge.java",
      "language": "JAVA",
      "line": 75,
      "offset": 53,
      "length": 12,
      "code": {
        "startLine": 73,
        "length": 12,
        "offset": 109,
        "surroundingCode": "\t\t}\n\t\tint health = random.nextInt(getValue() * 100) + 1;\n\t\tentity.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(health);\n\t\tentity.setHealth(health);\n\t}"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "ConstantConditions"
  },
  "hash": "f8c6e3b7534fb1036bbe192b1039cf2cdd6bbcf36c880c2c0b4ae1198ce64711"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/spigot/listener/HelpListener.java",
      "language": "JAVA",
      "line": 44,
      "offset": 42,
      "length": 2,
      "code": {
        "startLine": 42,
        "length": 2,
        "offset": 171,
        "surroundingCode": "\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"Â§7This server is running Â§eÂ§lChallenges Â§ev\" + Challenges.getInstance().getVersion());\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"\");\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"Â§7Made by Â§eCodingArea Â§8(Â§eanweisen Â§7& Â§eKxmischesDomiÂ§8)\");\n\t\tsender.sendMessage(Prefix.CHALLENGES + \"Â§7Visit the source at Â§egithub.com/anweisen/Challenges\");"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "96107c8f2abdb09aba5ef149b6b97c124bdfd0c64877c7936b4d20ef81db7b38"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class 'SpawnEntitiesEvent' may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 102,
      "offset": 15,
      "length": 18,
      "code": {
        "startLine": 100,
        "length": 18,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class SpawnEntitiesEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "9a281ac41c59283d6d67b06b0731053c6dfbddc8fd0f088c59a7c963a3665d29"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "severity": "High",
  "comment": "Inner class 'CobWebEvent' may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/challenges/implementation/challenge/RandomEventChallenge.java",
      "language": "JAVA",
      "line": 163,
      "offset": 15,
      "length": 11,
      "code": {
        "startLine": 161,
        "length": 11,
        "offset": 18,
        "surroundingCode": "\t}\n\n\tpublic class CobWebEvent implements Event {\n\n\t\t@Nonnull"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "b7b25810d93172803b8c15c2349c561a76d0bd35ac101d3af7464d5f34e4820a"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Pointless statement or boolean expression",
  "severity": "High",
  "comment": "'showPages && false' can be simplified to 'false'",
  "detailsInfo": "Reports unnecessary or overly complicated boolean expressions.\n\nSuch expressions include `&&`-ing with `true`,\n`||`-ing with `false`,\nequality comparison with a boolean literal, or negation of a boolean literal. Such expressions can be simplified.\n\nExample:\n\n\n      boolean a = !(x && false);\n      boolean b = false || x;\n      boolean c = x != true;\n\nAfter the quick-fix is applied:\n\n\n      boolean a = true;\n      boolean b = x;\n      boolean c = !x;\n\n\nConfigure the inspection:\nUse the **Ignore named constants in determining pointless expressions** option to ignore named constants when determining if an expression is pointless.",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/menu/InventoryTitleManager.java",
      "language": "JAVA",
      "line": 50,
      "offset": 63,
      "length": 18,
      "code": {
        "startLine": 48,
        "length": 18,
        "offset": 191,
        "surroundingCode": "\t@Nonnull\n\tpublic static String getMenuSettingTitle(@Nonnull MenuType menu, @Nonnull String name, int page, boolean showPages) {\n\t\treturn getTitle(\"Â§9\" + menu.getName() + \" Â§8â Â§9\" + name + (showPages && false ? \" Â§8â¢ Â§9\" + (page + 1) : \"\"));\n\t}\n"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "PointlessBooleanExpression"
  },
  "hash": "93160776e05a61694057474b2f4596798a9744886a7c165e661ff0a5aa98c3fd"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Unused assignment",
  "severity": "High",
  "comment": "Variable 'hasCheated' initializer 'false' is redundant",
  "detailsInfo": "Reports assignment values that are not used after the assignment. If the assignment value is unused, it's better to remove the assignment to shorten the code and avoid redundant allocations.\n\nThe following cases are reported:\n\n* The variable never gets read after the assignment.\n* The variable is always overwritten with a new value before it is read.\n* The variable initializer is redundant (for one of the two reasons above).\n\nConfigure the inspection:\n\n\nUse the **Report redundant initializers** option to report redundant initializers:\n\n\n      int getI() {\n        int i = 0; // redundant initialization\n        i = 2;\n        return i;\n      }\n\n\nUse the **Report ++i when may be replaced with (i + 1)** option to report the cases when `++i` expression\nmay be replaced with `i + 1`:\n\n\n      int preInc(int i) {\n        int res = i;\n        return ++res;\n      }\n\n\nUse the **Report i++ when changed value is not used afterwards** option to report the cases when the result of `i++` expression\nis not used later:\n\n\n      int postInc(int i) {\n        int res = i;\n        return res++;\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "plugin/src/main/java/net/codingarea/challenges/plugin/management/server/ServerManager.java",
      "language": "JAVA",
      "line": 38,
      "offset": 31,
      "length": 5,
      "code": {
        "startLine": 36,
        "length": 5,
        "offset": 113,
        "surroundingCode": "\n\tprivate boolean isFresh; // This indicated if the timer was never started before\n\tprivate boolean hasCheated = false;\n\n\tpublic ServerManager() {"
      }
    }
  ],
  "attributes": {
    "module": "plugin",
    "inspectionName": "UnusedAssignment"
  },
  "hash": "3c4937e2e6e432d066bc525db83de507d3531143e00aa76aa02a18fcfb5feec0"
}]}